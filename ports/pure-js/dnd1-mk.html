<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<script>
function ddinit()
{
	document.write('<textarea id="console" cols="70" rows="22">');
	document.write('</textarea>');
	//document.write('<pre id="console">');
	//document.write('</pre>');
	document.write('<br>');
	document.write('<input id="command" name="command" type="text" size="80" onkeydown="Javascript: if (event.keyCode==13) ddcliinterpreter(this)">');
	document.write('<br>');
	document.write("\n");
	document.write('<span id="mappad">');
	document.write('</span>');
	document.write("\n");
	document.write('<span id="charpad">');
	document.write('</span>');
	document.write("\n");
	document.write('<span id="eqpad">');
	document.write('</span>');
	document.write("\n");
	document.write('<span id="spellpad">');
	document.write('</span>');
	document.write("\n");
	consoleobj = document.getElementById('console');
	//consoleobj.style.font="bold 12px courier,monospace";
	//consoleobj.style.backgroundColor='#000000';
	//consoleobj.style.color='#FFFFFF';
	consoleobj.style.lineHeight='90%';
	consoleobj.disabled = true;
	commandobj = document.getElementById('command');
	commandobj.style.lineHeight='90%';
	passthru = '';
	mappadobj = document.getElementById('mappad');
	mappadobj.style.lineHeight='70%';
	mappadobj.style.backgroundColor='#000000';
	mappadobj.style.color='#FFFFFF';
	//mappadobj.style.width='92px';
	//mappadobj.style.display='table-cell';
	mappadobj.style.fontSize='x-large';
	//mappadobj.style.fontStretch='ultra-expanded';
	//mappadobj.style.letterSpacing='1px';
	mappadobj.style.cssFloat='left';
	mappadobj.style.fontFamily='monospace';
	mappadobj.style.whiteSpace='pre';
	charpadobj = document.getElementById('charpad');
	//charpadobj.style.display='table-cell';
	//charpadobj.style.fontSize='x-large';
	charpadobj.style.padding='4px 0px 0px 12px';
	charpadobj.style.cssFloat='left';
	charpadobj.style.fontFamily='monospace';
	charpadobj.style.whiteSpace='pre';
	charpadobj = document.getElementById('charpad');
	eqpadobj = document.getElementById('eqpad');
	//eqpadobj.style.display='table-cell';
	//eqpadobj.style.display='inline';
	eqpadobj.style.cssFloat='left';
	//eqpadobj.style.fontSize='x-large';
	eqpadobj.style.padding='4px 0px 0px 12px';
	eqpadobj.style.fontFamily='monospace';
	eqpadobj.style.whiteSpace='pre';
	spellpadobj = document.getElementById('spellpad');
	spellpadobj.style.cssFloat='left';
	//spellpadobj.style.fontSize='x-large';
	spellpadobj.style.padding='4px 0px 0px 12px';
	spellpadobj.style.fontFamily='monospace';
	spellpadobj.style.whiteSpace='pre';
	ddresizeforphone();
	ddinitglobalmemory();
	ddintro();
}

/*
Part of the issue with phones is the browser will auto zoom on form
elements so it is difficult to figure out what pixel size the console
and the command line should be.
*/
function ddresizeforphone()
{
	var windowwidth = window.innerWidth;
	var windowheight = window.innerHeight;
	var windowratio = windowwidth / windowheight;
	dddebug(windowwidth);
	dddebug(windowheight);
	dddebug(windowratio);
	//if( (windowwidth < 600) && (windowratio < 1) )
	if( (windowratio < .85) )
	{
		//consoleobj.width = Math.floor(windowwidth / 4);
		//consoleobj.height = Math.floor(windowheight / 4);
		consoleobj.cols = 32;
		consoleobj.rows = 8;
	}
}

/*
Some notes on general code flow. After ddintro is done chaining
through the introduction functions, the code is done for that
operation. There is not a while loop. The commandobj is what
initiates the next chain of functions. Then that chain will come
to an end. The commandobj will then be left to initiate the next
chain of functions. Which functions get invoked depend on what
the passthru variable has been set to and also by what the player
has entered in the commandobj as cliinput.
*/
function ddintro()
{
	ddwr("     RICHARD GARRIOTT DND1");
	ddwr("");
	ddwr("DO YOU NEED INSTRUCTION (Y)ES (N)O");
	ddwrgetinput('ddinstruction');
}

function ddinstruction(cliinput)
{
	if((cliinput == 'Y') || (cliinput == 'YES'))
	{
		//01730
		ddwr("WHO SAID YOU COULD PLAY");
		return;
	}
	else if((cliinput == 'N') || (cliinput == 'NO'))
	{
		//00380
		ddwr("(O)LD OR (N)EW GAME");
		ddwrgetinput('ddoldnewgame');
	}
	else
	{
		ddwrgetinput('ddinstruction');
	}
}

function ddoldnewgame(cliinput)
{
	if((cliinput == 'O') || (cliinput == 'OLD'))
	{
		//TODO 01770
		ddwr("NOT IMPLEMENTED YET");
		ddwr("(O)LD OR (N)EW GAME");
		ddwrgetinput('ddoldnewgame');
		return;
	}
	else if((cliinput == 'N') || (cliinput == 'NEW'))
	{
		//ddwr("DUNGEON #");
		ddwr("DUNGEON # (1) (2) (3) (4) (5) (6)");
		ddwrgetinput('dddungeonnumber');
		return;
	}
	else
	{
		ddwrgetinput('ddoldnewgame');
	}
}

/*
line
*/
function dddungeonnumber(cliinput)
{
	cliinput = parseInt(cliinput);
	ddglobal['D'] = cliinput;
	if((cliinput >= 0) && (cliinput <= 6))
	{
		//ddwr("CONTINUES RESET 1=YES,2=NO ");
		ddwr("CONTINUES RESET (1)=YES,(2)=NO ");
		ddwrgetinput('ddcontinuereset');
	}
	else
	{
		ddwrgetinput('dddungeonnumber');
	}
}

/*
line 00422
This pertains to whether the dungeon should continously reset
monsters, over and over again so there is never an end.
*/
function ddcontinuereset(cliinput)
{
	ddglobal['J6'] = 99;
	if(cliinput == '1')
	{
		ddglobal['J6'] = 1;
	}
	else if(cliinput == '2')
	{
		ddglobal['J6'] = 2;
	}
	else
	{
		ddwrgetinput('ddcontinuereset');
	}
	if((ddglobal['J6'] == 1) || (ddglobal['J6'] == 2))
	{
		ddwr("PLAYERS NME ");
		ddwrgetinput('ddplayersname');
	}
}

/*
line 00450
*/
function ddplayersname(cliinput)
{
	ddglobal['NS'] = 99;
	if(cliinput == 'SHAVS')
	{
		ddgeneratestats();
		ddclassification_pre();
	}
	else
	{
		//01730
		ddwr("WHO SAID YOU COULD PLAY");
		return;
	}
}

/*
line 00470
*/
function ddgeneratestats()
{
	ddglobal['C'] = Array();
	//set hit points to 0
	ddglobal['C'][0] = 0;
	for(var M = 1; M <= 7; M++)
	{
		ddglobal['C'][M] = 0;
		for(var N = 1; N <= 3; N++)
		{
			var R = ddrandom(1, 6);
			ddglobal['C'][M] = ddglobal['C'][M] + R;
		}
		if(M != 7)
		{
			ddwr(ddglobal['CS'][M]+"="+ddglobal['C'][M]);
		}
		else
		{
			//ddglobal['C'][M] = ddglobal['C'][M] * 15;
			//setting gold to a 1000 for testing
			ddglobal['C'][7] = ddglobal['C'][7] = 1000;
		}
	}
}

/*
line 00580
*/
function ddclassification_pre()
{
	ddwr("");
	ddwr("CLASSIFICATION");
	ddwr("WHICH DO YOU WANT TO BE");
	ddwr("(F)IGHTER ,(C)LERIC ,OR (W)IZARD");
	ddwrgetinput('ddclassification');
}

/*
line 00620
*/
function ddclassification(cliinput)
{
	ddglobal['CS'][0] = '';
	if((cliinput == 'F') || (cliinput == 'FIGHTER'))
	{
		ddglobal['CS'][0] = 'FIGHTER';
		//ddglobal['C'][0] = ddrandom(1, 8);
		ddglobal['C'][0] = ddglobal['C'][3] + ddrandom(1, 8);
		ddbuyingweapons_pre();
	}
	else if((cliinput == 'C') || (cliinput == 'CLERIC'))
	{
		ddglobal['CS'][0] = 'CLERIC';
		//ddglobal['C'][0] = ddrandom(1, 6);
		ddglobal['C'][0] = ddglobal['C'][3] + ddrandom(1, 6);
		ddbuyingweapons_pre();
	}
	else if((cliinput == 'W') || (cliinput == 'WIZARD'))
	{
		ddglobal['CS'][0] = 'WIZARD';
		//ddglobal['C'][0] = ddrandom(1, 4);
		ddglobal['C'][0] = ddglobal['C'][3] + ddrandom(1, 4);
		ddbuyingweapons_pre();
	}
	else if(cliinput == 'NONE')
	{
		ddglobal['CS'][0] = 'NONE';
		//NONE is like reroll
		//line 00625
		ddgeneratestats();
		ddclassification_pre();
	}
	else
	{
		ddwrgetinput('ddclassification');
	}
}

/*
line 00670
*/
function ddbuyingweapons_pre()
{
	ddwr("BUYING WEAPONS");
	ddwr("NUMBER","ITEM","PRICE");
	//TODO fast or norm routine
	ddwr("(0)- STOP");
	for(var M = 1; M <= 16; M++)
	{
		ddwr("("+M+")- "+ddglobal['IS'][M]+" - "+ddglobal['P'][M]);
	}
	ddwrgetinput('ddbuyingweapons');
}

/*
line 00830
*/
function ddbuyingweapons(cliinput)
{
	//ddglobal['Y'] = cliinput;
	if(cliinput == 'L')
	{
		ddbuyingweapons_pre();
	}
	else
	{
		//this varies from the old code
		if(isNaN(cliinput))
		{
			ddwr("ENTER NUMBER 0 - 16 or L");
			ddwrgetinput('ddbuyingweapons');
		}
		else
		{
			cliinput = parseInt(cliinput);
			ddglobal['Y'] = cliinput;
			if((cliinput < 1) || (cliinput > 16))
			{
				ddgoldcount_pre();
			}
			else
			{
				ddpurchasecheck();
			}
		}
	}
}

/*
line 00890
line 00970
*/
function ddpurchasecheck()
{
	if( (ddglobal['C'][7] - ddglobal['P'][ddglobal['Y']]) < 0 )
	{
		ddwr("COSTS TOO MUCH");
		ddwr("TRY AGAIN ");
		ddwrgetinput('ddbuyingweapons');
	}
	else
	{
		if( ddglobal['CS'][0] == 'CLERIC' )
		{
			if( (ddglobal['Y'] == 4) || (ddglobal['Y'] == 8) || (ddglobal['Y'] == 9) || (ddglobal['Y'] > 10) )
			{
				ddpurchaseit();
			}
			else
			{
				ddwr("YOUR A CLERIC YOU CANT USE THAT ");
				ddwr("ENTER NUMBER 0 - 16 or L");
				ddwrgetinput('ddbuyingweapons');
			}
		}
		else if( ddglobal['CS'][0] == 'WIZARD' )
		{
			if( (ddglobal['Y'] == 3) || (ddglobal['Y'] == 8) || (ddglobal['Y'] > 10) )
			{
				ddpurchaseit(ddglobal['Y']);
			}
			else
			{
				ddwr("YOUR A WIZARD YOU CANT USE THAT ");
				ddwr("ENTER NUMBER 0 - 16 or L");
				ddwrgetinput('ddbuyingweapons');
			}
		}
		else
		{
			//fighter can buy anything
			ddpurchaseit(ddglobal['Y']);
		}
	}
}

/*
line 00920
might want to replace ddglobal['Y'] in here with Y
*/
function ddpurchaseit(Y)
{
	//reduce gold
	ddglobal['C'][7] = ddglobal['C'][7] - ddglobal['P'][ddglobal['Y']];
	ddwr("GP= "+ddglobal['C'][7]);
	//line 00830
	//keeps track of how many items have been bought
	ddglobal['X'] = ddglobal['X'] + 1;
	ddglobal['W'][ddglobal['X']] = ddglobal['Y'];
	ddwr("ENTER NUMBER 0 - 16 or L");
	ddwrgetinput('ddbuyingweapons');
}

/*
line 01000
*/
function ddgoldcount_pre()
{
	ddwr("GP= "+ddglobal['C'][7]);
	ddwr("EQ LIST (Y)ES (N)O");
	ddwrgetinput('ddequipmentlist');
}

/*
line 01030
*/
function ddequipmentlist(cliinput)
{
	ddglobal['QS'] = '';
	if((cliinput == "N") || (cliinput == "NO"))
	{
		ddcharactersheet();
	}
	else
	{
		for(var M = 1; M <= ddglobal['X']; M++)
		{
			if( ddglobal['W'][M] != 0 )
			{
				ddwr(ddglobal['W'][M]+" - "+ddglobal['IS'][ddglobal['W'][M]]);
			}
		}
		ddcharactersheet();
	}
}

/*
line 01090
*/
function ddcharactersheet()
{
	ddwr("YOUR CHARACTERISTICS ARE");
	ddwr(ddglobal['CS'][0]);
	//bump up hit points if 1
	if(ddglobal['C'][0] == 1)
	{
		ddglobal['C'][0] = 2;
	}
	ddwr("HIT POINTS "+ddglobal['C'][0]);
	ddloaddungeon();
}

/*
line 01415
*/
function ddloaddungeon()
{
	//we really need to have ddglobal['D'] set by now
	//might want to write a check for it here
	ddwr("LOADING DUNGEON NUM. "+ddglobal['D']);
	for(var M = 0; M <= 25; M++)
	{
		ddglobal['DA'][M] = Array();
		for(var N = 0; N <= 25; N++)
		{
			if( (ddglobal['D'] >= 0) && (ddglobal['D'] <= 6) )
			{
				if(ddglobal['D'] == 0)
				{
					ddglobal['DA'][M][N] = 0;
				}
				else
				{
					ddglobal['DA'][M][N] = ddstockdungeontile(ddglobal['FILE'][ddglobal['D']][M][N]);
				}
			}
			else
			{
				//we have a problem in that D is a number we can not use
			}
		}
	}
	//ddwr("DEBUG DISPLAY DUNGEON");
	//dddisplaydungeon(ddglobal['DA']);
	ddyeastart();
}

/*
line 01443
*/
function ddstockdungeontile(tiletypenumber)
{
	tiletypenumber = parseInt(tiletypenumber);
	var newtiletypenumber = 0;
	if(tiletypenumber != 0)
	{
		newtiletypenumber = tiletypenumber;
	}
	else if(tiletypenumber == 0)
	{
		//Original values are 97 and above
		if(  ddrandom(1,100) >= 99  )
		{
			newtiletypenumber = 7;
		}
		if(  ddrandom(1,100) >= 99  )
		{
			newtiletypenumber = 8;
		}
	}
	return newtiletypenumber;
}

/*
line 01470
*/
function ddyeastart()
{
	//ddwr("");
	//ddwr("");
	ddwr("");
	ddwr("WELCOME TO DUNGEON #"+ddglobal['D']);
	ddwr("");
	ddcommandlist_pre();
}

/*
line 01590
The path flow of functions can be confusing.
My plan here is that ddcommandlist_pre is one major flow point.
All function calls that start with issuing a command here, even though
they often chain to other function calls, in the end, at the end of the
chain they should either call ddcommandlist_pre or ddmaintimeloop.
Which function to call at the end depends on whether we feel that the
character has spent a round doing something or if they should get a
free do over command.
*/
function ddcommandlist_pre()
{
	//ddshowstacktrace();
	//ddwr("YOU ARE AT ("+ddglobal['G']+","+ddglobal['H']+")");
	//ddwr("COMMANDS LIST");
	//kabalyero wanted auto looking
	ddautolookaround();
	ddupdatecharpad();
	ddupdateeqpad();
	ddupdatespellpad();
	//ddwr("YOU ARE AT ("+ddglobal['G']+","+ddglobal['H']+")  COMMANDS LIST");
	//ddwr("1=MOVE  2=OPEN DOOR  3=SEARCH FOR TRAPS AND SECRET DOORS");
	//ddwr("4=SWITCH WEAPON HN HAND  5=FIGHT");
	//ddwr("6=LOOK AROUND  7=SAVE GAME  8=USE MAGIC  9=BUY MAGIC");
	//ddwr("0=PASS  11=BUY H.P.");
	ddwr("YOU ARE AT ("+ddglobal['G']+","+ddglobal['H']+")  COMMANDS LIST");
	ddwr("1=MOVE 2=OPEN DOOR 3=SEARCH 4=EQUIP WEAPON 5=FIGHT 6=LOOK");
	ddwr("7=SAVE GAME 8=USE MAGIC 9=BUY MAGIC 0=PASS 11=BUY H.P.");
	ddwrgetinput('ddcommandlist');
}

function ddshowstacktrace()
{
	e = new Error();
	console.log(e.stack);
}

/*
line 01600
Consequently, all functions should return back to nothing as code flow
is determined more by the last function call at the end of the chain.
*/
function ddcommandlist(cliinput)
{
	//ddglobal['T'] = 999;
	if(isNaN(cliinput))
	{
		//really need to standardize number vs string in cliinterpreter
	}
	else if(cliinput == 0)
	{
		ddglobal['T'] = 0;
		//GOTO 07000
		ddmaintimeloop();
	}
	else if(cliinput == 1)
	{
		ddglobal['T'] = 1;
		//GOTO 02170
		ddmovearound_pre();
	}
	else if(cliinput == 2)
	{
		ddglobal['T'] = 2;
		//GOTO 03130
		ddopendoor_pre();
	}
	else if(cliinput == 3)
	{
		ddglobal['T'] = 3;
		//GOTO 03430
		ddsearchforsecret();
	}
	else if(cliinput == 4)
	{
		ddglobal['T'] = 4;
		//GOTO 03640
		ddequipweapon_pre();
	}
	else if(cliinput == 5)
	{
		ddglobal['T'] = 5;
		//GOTO 03750
		ddfightback();
	}
	else if(cliinput == 6)
	{
		ddglobal['T'] = 6;
		//GOTO 06390
		ddlookaround();
	}
	else if(cliinput == 7)
	{
		ddglobal['T'] = 7;
		//GOTO 06610
		ddsavegame();
	}
	else if(cliinput == 8)
	{
		ddglobal['T'] = 8;
		//GOTO 08680
		ddcastmagic();
	}
	else if(cliinput == 9)
	{
		ddglobal['T'] = 9;
		//GOTO 09980
		ddbuymagic();
	}
	else if(cliinput == 10)
	{
		ddglobal['T'] = 10;
		ddlookcheat();
		//GOTO 10730
	}
	else if(cliinput == 11)
	{
		ddglobal['T'] = 11;
		ddbuyhp_pre();
		//GOTO 10830
	}
	else if(cliinput == 12)
	{
		ddglobal['T'] = 12;
		ddgodmodemapedit_pre();
		//GOTO 11000
	}
	else
	{
		//we have bad input data
		ddcommandlist_pre();
	}
}

/*
line 06390
*/
function ddlookaround()
{
	//REM LOOKING
	for(var M = -5; M <= 5; M++)
	{
		var linestring = '';
		for(var N = -5; N <= 5; N++)
		{
			if( (ddglobal['G'] + M) > 25 )
			{

			}
			else if( (ddglobal['G'] + M) < 0 )
			{

			}
			else if( (ddglobal['H'] + N) > 25 )
			{

			}
			else if( (ddglobal['H'] + N) < 0 )
			{

			}
			else if( (M == 0) && (N == 0) )
			{
				linestring = linestring+'9';
			}
			else
			{
				linestring = linestring+''+ddseeversusreal(M, N);
			}
		}
		ddwr(linestring);
	}
	//Original code would burn a turn
	//ddmaintimeloop();
	ddcommandlist_pre();
}

function ddautolookaround()
{
	var mapstring = '';
	//REM LOOKING
	for(var M = -5; M <= 5; M++)
	{
		var linestring = '';
		for(var N = -5; N <= 5; N++)
		{
			if( (ddglobal['G'] + M) > 25 )
			{

			}
			else if( (ddglobal['G'] + M) < 0 )
			{

			}
			else if( (ddglobal['H'] + N) > 25 )
			{

			}
			else if( (ddglobal['H'] + N) < 0 )
			{

			}
			else if( (M == 0) && (N == 0) )
			{
				linestring = linestring+'9';
			}
			else
			{
				linestring = linestring+''+ddseeversusreal(M, N);
			}
		}
		//ddwr(linestring);
		mapstring = mapstring+linestring+"\n";
	}
	ddupdatemappad(mapstring);
	//Original code would burn a turn
	//ddmaintimeloop();
	//ddcommandlist_pre();
}

function ddupdatecharpad()
{
	var csh = '';

	csh = csh+'NAME:'+'SHAVS'+"\n";
	csh = csh+'CLASS:'+ddglobal['CS'][0]+"\n";
	csh = csh+'STR:'+ddglobal['C'][1]+"\n";
	csh = csh+'DEX:'+ddglobal['C'][2]+"\n";
	csh = csh+'CON:'+ddglobal['C'][3]+"\n";
	csh = csh+'INT:'+ddglobal['C'][4]+"\n";
	csh = csh+'WIS:'+ddglobal['C'][5]+"\n";
	csh = csh+'CHA:'+ddglobal['C'][6]+"\n";
	csh = csh+''+"\n";
	csh = csh+'HP:'+ddglobal['C'][0]+"\n";
	csh = csh+'GOLD:'+ddglobal['C'][7]+"\n";

	charpadobj.innerHTML = csh;
}

function ddupdateeqpad()
{
	var csh = '';
	csh = csh+'EQUIPMENT'+"\n";
	for( M = 1; M <= ddglobal['X']; M++)
	{
		if( ddglobal['W'][M] != 0 )
		{
			csh = csh+ddglobal['W'][M]+" - "+ddglobal['IS'][ddglobal['W'][M]]+"\n";
		}
	}
	eqpadobj.innerHTML = csh;
}

function ddupdatespellpad()
{
	var csh = '';
	csh = csh+'SPELLS'+"\n";
	for( M = 1; M <= ddglobal['X1']; M++)
	{
		if( ddglobal['X2'][M] != 0 )
		{
			csh = csh+ddglobal['X2'][M]+" - "+ddglobal['E1'][ddglobal['X2'][M]]+"\n";
		}
	}
	for( M = 1; M <= ddglobal['X3']; M++)
	{
		if( ddglobal['X4'][M] != 0 )
		{
			csh = csh+ddglobal['X4'][M]+" - "+ddglobal['E3'][ddglobal['X4'][M]]+"\n";
		}
	}
	spellpadobj.innerHTML = csh;
}

/*
line 06550
*/
function ddseeversusreal(lookm, lookn)
{
	var displaychar = '';
	if( ddcheckplacementbounds(lookm, lookn) == true )
	{
		var locg = ddglobal['G'] + lookm;
		var loch = ddglobal['H'] + lookn;
		var tiletypenumber = ddglobal['DA'][locg][loch];
		if( tiletypenumber == 0 )
		{
			displaychar = ' ';
		}
		else if( tiletypenumber == 1 )
		{
			displaychar = '*';
		}
		else if( tiletypenumber == 2)
		{
			displaychar = ' ';
		}
		else if( tiletypenumber == 3)
		{
			//secret door
			displaychar = '*';
		}
		else if( tiletypenumber == 4)
		{
			displaychar = '4';
		}
		else if( tiletypenumber == 5)
		{
			displaychar = '5';
		}
		else if( tiletypenumber == 6)
		{
			displaychar = 'O';
		}
		else if( tiletypenumber == 7)
		{
			displaychar = '.';
		}
		else if( tiletypenumber == 8)
		{
			displaychar = '.';
		}
		else
		{
			displaychar = tiletypenumber;
		}
	}
	else
	{
		displaychar = ' ';
	}
	return displaychar;
}

/*
line 07000
Evrything comes here when a turn has passed. Hard to follow.
Original code would sometimes just jump right back to here instead
of going through normal flow.
I am going to try and have each function just flow without having
a final function call that jumps to somewhere else. Except for in
this function, at the end, it calls the ddcommandlist_pre to get
input from the player to find out what they want to do.
*/
function ddmaintimeloop()
{
	dddebug(ddglobal['H']);
	dddebug(ddglobal['G']);
	//check to see if monster died from attacks
	if( ddglobal['K1'] == -1 )
	{
		//A monster is dead
		ddmonsterdead();
	}
	//check to see if character is hurt or dead
	if( ddglobal['C'][0] < 2 )
	{
		ddplayerhurtbad();
	}
	//This was not in the original code
	//Despawn if a monster has not moved or attacked for 10 rounds
	if( ddglobal['K'] > 0 )
	{
		if( ddglobal['I9'] > 20 )
		{
			//monster is bored
			ddwr("MONSTER SLIPS AWAY INTO THE DARKNESS");
			ddmonsterfled();
		}
	}
	//if we still have a monster check for attacks
	if( ddglobal['K'] > 0 )
	{
		//GOTO 07160
		//07160 GOSUB 08410
		ddrangeandhitcheck();
		dddebug("R1="+ddglobal['R1']);
		if( ddglobal['B'][ddglobal['K']][3] < 1 )
		{
			//GOTO 08290
			ddmonsterdead();
			//That should send it back ddmaintimeloop
			//Need to think more on the consequences of that program flow
		}
		else if( ddglobal['R1'] < 2.0 )
		{
			//GOTO 07600
			ddmonsterisclose();
		}
	}
	//I dont see how the monster could have died in the above
	if( ddglobal['K'] > 0 )
	{
		ddmovemonstercloser();
	}
	//Might as well update monster range before we get to character action
	if( ddglobal['K'] > 0)
	{
		ddrangeandhitcheck();
	}


	if( (ddglobal['G'] == 1 ) && (ddglobal['H'] == 12) )
	{
		//TODO Change this into a tile number?
		//so the equipment shop can be placed anywhere
		//I also feel this does not fit the other functions in flow
		//ddequipmentshoptile_pre();
	}

	//I think the original code would never get here
	//if there was already a monster running around
	if( ddglobal['K'] == 0 )
	{ 
		if( ddrandom(1, 20) > 10 )
		{
			//GOTO 07830
			ddwanderingmonster();
			//The original code would have a GOTO 07000
		}
	}
	//At the end of the loop we ask the player what to do again
	ddcommandlist_pre();
}

/*
line 02170
*/
function ddmovearound_pre()
{
	ddwr("YOU ARE AT "+ddglobal['G']+" , "+ddglobal['H']);
	ddwr("  (D)OWN  (R)IGHT  (L)EFT  OR  (U)P");
	ddwrgetinput('ddmovearound');
}

/*
line 2190
*/
function ddmovearound(cliinput)
{
	ddglobal['QS'] = '';
	ddglobal['S'] = 0;
	ddglobal['T'] = 0;
	if( (cliinput == 'R') || (cliinput == 'RIGHT') || (cliinput == 'E') || (cliinput == 'EAST' ) )
	{
		ddglobal['QS'] = 'RIGHT';
		ddglobal['S'] = 0;
		ddglobal['T'] = 1;
		ddcheckmovespot();
	}
	else if( (cliinput == 'L') || (cliinput == 'LEFT') || (cliinput == 'W') || (cliinput == 'WEST') )
	{
		ddglobal['QS'] = 'LEFT';
		ddglobal['S'] = 0;
		ddglobal['T'] = -1;
		ddcheckmovespot();
	}
	else if( (cliinput == 'U') || (cliinput == 'UP') || (cliinput == 'N') || (cliinput == 'NORTH') )
	{
		ddglobal['QS'] = 'UP';
		ddglobal['S'] = -1;
		ddglobal['T'] = 0;
		ddcheckmovespot();
	}
	else if( (cliinput == 'D') || (cliinput == 'DOWN') || (cliinput == 'S') || (cliinput == 'SOUTH') )
	{
		ddglobal['QS'] = 'DOWN';
		ddglobal['S'] = 1;
		ddglobal['T'] = 0;
		ddcheckmovespot();
	}
	else
	{
		//we have an unknown input
		ddmovearound_pre();
	}
}

/*
line 02370
02369 REM 0 = SPACE, 1 = WALL, 2 = TRAP
02369 REM 3 = SECRET, 5 = MONSTER, 6 = GOLD
02369 REM 7 = ST BONUS, 8 = IN BONUS
*/
function ddcheckmovespot()
{
	var locg = ddglobal['G'] + ddglobal['S'];
	var loch = ddglobal['H'] + ddglobal['T'];
	var tiletypenumber = ddglobal['DA'][locg][loch];
	if( tiletypenumber == 0 )
	{
		//GOTO 02430
		ddsimplemove();
	}
	else if( tiletypenumber == 1 )
	{
		//GOTO 02480
		ddwr("YOU RAN INTO A WALL");
		ddranintowall();
	}
	else if( tiletypenumber == 2 )
	{
		//GOTO 02550
		ddranintotrap();
	}
	else if( tiletypenumber == 3 )
	{
		//GOTO 02990
		ddranintosecret();
	}
	else if( tiletypenumber == 4 )
	{
		ddwr("YOU RAN INTO A DOOR");
		ddranintowall();
	}
	else if( tiletypenumber == 5 )
	{
		//GOTO 03060
		ddranintomonster();
	}
	else if( tiletypenumber == 6 )
	{
		//GOTO 02413
		ddranintogold();
	}
	else if( tiletypenumber == 7 )
	{
		//GOTO 02424
		ddincreasestr();
	}
	else if( tiletypenumber == 8 )
	{
		//GOTO 02426
		ddincreasecon();
	}
}

/*
line 02430
*/
function ddsimplemove()
{
	ddglobal['G'] = ddglobal['G'] + ddglobal['S'];
	ddglobal['H'] = ddglobal['H'] + ddglobal['T'];
	ddmaintimeloop();
}

/*
line 02480
*/
function ddranintowall()
{
	//moved message out since this is used by runintodoor
	//ddwr("YOU RAN INTO A WALL");
	if( ddrandom(1, 12) > 9 )
	{
		ddwr("AND LOOSE 1 HIT POINT");
		ddglobal['C'][0] = ddglobal['C'][0] - 1;
	}
	else
	{
		ddwr("BUT NO DAMAGE WAS INFLICTED");
	}
	ddmaintimeloop();
}

/*
line 02550
*/
function ddranintotrap()
{
	//not sure if this is a bug in the original code
	//but we have to actually move the character location
	//so they are on top of the trap spot
	ddglobal['G'] = ddglobal['G'] + ddglobal['S'];
	ddglobal['H'] = ddglobal['H'] + ddglobal['T'];
	ddwr("OOOOPS A TRAP AND YOU FELL IN ");
	if( ddrandom(1, 3) > 2 )
	{
		ddwr("AND HIT POINTS LOOSE 1");
		ddglobal['C'][0] = ddglobal['C'][0] - 1;
	}
	ddwr("I HOPE YOU HAVE SOME SPIKES AND PREFERABLY ROPE");
	ddwr("LET ME SEE");
	var inventoryspike = ddcheckforspike();
	var inventoryrope = ddcheckforrope();
	if( inventoryspike != 0 )
	{
		//line 02640
		ddglobal['W'][inventoryspike] = 0;
		if( inventoryrope != 0 )
		{
			ddglobal['W'][inventoryspike] = 0;
			ddwr("GOOD BOTH");
			ddtrapescape();
		}
		else
		{
			ddnoropebutspike();
		}
	}
	else
	{
		ddnospikedead();
	}

}

/*
line 02620
*/
function ddcheckforspike()
{
	var inventorylocation = false;
	for(var M = 1; M <= ddglobal['X']; M++)
	{
		if( ddglobal['W'][M] == 12 )
		{
			inventorylocation = M;
		}
	}
	return inventorylocation;
}

/*
line 02680
*/
function ddcheckforrope()
{
	var inventorylocation = 0;
	for(var M = 1; M <= ddglobal['X']; M++)
	{
		if( ddglobal['W'][M] == 11 )
		{
			inventorylocation = M;
		}
	}
	return inventorylocation;
}

/*
02740 PRINT "NO SPIKES AH THATS TOO BAD CAUSE YOUR DEAD "
02750 STOP
*/
function ddnospikedead()
{
	ddwr("NO SPIKES AH THATS TOO BAD CAUSE YOUR DEAD ");
	ddendprogram();
}

/*
line 02890
*/
function ddnoropebutspike()
{
	ddwr("NO ROPE BUT AT LEAS SPIKES");
	if( (ddrandom(1, 3) + 1) == 2 )
	{
		//line 02960
		ddwr("OOPS H.P. LOOSE 1");
		ddglobal['C'][0] = ddglobal['C'][0] - 1;
		ddwr("TRY AGAIN ");
		//seems like a pontential bug
		//keep losing hit points in rare circumstances
		//long after character is already dead
		ddnoropebutspike();
	}
	else
	{
		ddtrapescape();
	}
}

/*
line 02770
*/
function ddtrapescape()
{
	ddwr("YOU MANAGE TO GET OUT EASY");
	ddwr("YOUR STANDING NEXT TO THE EDGE THOUGH I'D MOVE");
	//GOTO 02170
	//gets a free move to get off trap spot
	ddmovearound_pre();
}

/*
line 10740
*/
function ddlookcheat()
{
	for(var M = 0; M <= 25; M++)
	{
		var linetext = '';
		for(var N = 0; N <=25; N++)
		{
			linetext = linetext+''+ddglobal['DA'][M][N];
		}
		ddwr(linetext);
	}
	//GOTO 01590
	ddcommandlist_pre();
}

/*
line 03130
*/
function ddopendoor_pre()
{
	ddwr("DOOR (L)EFT (R)IGHT (U)P OR (D)OWN");
	ddwrgetinput('ddopendoor');
}

/*
line 03140
this code is very similar to line 2190
perhaps it can be merged
*/
function ddopendoor(cliinput)
{
	ddglobal['QS'] = '';
	ddglobal['S'] = 0;
	ddglobal['T'] = 0;
	if( (cliinput == 'R') || (cliinput == 'RIGHT') || (cliinput == 'E') || (cliinput == 'EAST' ) )
	{
		ddglobal['QS'] = 'RIGHT';
		ddglobal['S'] = 0;
		ddglobal['T'] = 1;
		ddcheckdoorspot();
	}
	else if( (cliinput == 'L') || (cliinput == 'LEFT') || (cliinput == 'W') || (cliinput == 'WEST') )
	{
		ddglobal['QS'] = 'LEFT';
		ddglobal['S'] = 0;
		ddglobal['T'] = -1;
		ddcheckdoorspot();
	}
	else if( (cliinput == 'U') || (cliinput == 'UP') || (cliinput == 'N') || (cliinput == 'NORTH') )
	{
		ddglobal['QS'] = 'UP';
		ddglobal['S'] = -1;
		ddglobal['T'] = 0;
		ddcheckdoorspot();
	}
	else if( (cliinput == 'D') || (cliinput == 'DOWN') || (cliinput == 'S') || (cliinput == 'SOUTH') )
	{
		ddglobal['QS'] = 'DOWN';
		ddglobal['S'] = 1;
		ddglobal['T'] = 0;
		ddcheckdoorspot();
	}
	else
	{
		//unknown input
		ddopendoor_pre();
	}
}

/*
line 03310
*/
function ddcheckdoorspot()
{
	var locg = ddglobal['G'] + ddglobal['S'];
	var loch = ddglobal['H'] + ddglobal['T'];
	var tiletypenumber = ddglobal['DA'][locg][loch];
	if( (tiletypenumber == 4) || (tiletypenumber == 3) )
	{
		ddwr("PUSH");
		if( ddrandom(1, 20) < ddglobal['C'][1] )
		{
			ddwr("ITS OPEN");
			ddglobal['G'] = locg;
			ddglobal['H'] = loch;
			ddwr("DONE");
			ddmaintimeloop();
		}
		else
		{
			ddwr("DIDNT BUDGE");
			ddmaintimeloop();
		}
	}
	else
	{
		ddwr("THERE IS NOT A DOOR THERE");
		ddmaintimeloop();
	}
}

/*
line 02990
*/
function ddranintosecret()
{
	//I think there is a bug in the basic program where you never
	//can find secret doors. Fixed it in js version here.
	if( ddrandom(1, 6) > 4 )
	{
		ddwr("YOU JUST RAN INTO A SECRET DOOR");
		ddwr("AND OPENED IT");
		ddglobal['G'] = ddglobal['G'] + ddglobal['S'];
		ddglobal['H'] = ddglobal['H'] + ddglobal['T'];
		ddwr("DONE");
		ddmaintimeloop();
	}
	else
	{
		ddwr();
		ddwr("YOU RAN INTO A WALL");
		ddranintowall();
	}
}

/*
line
*/
function ranintomonster()
{
	ddwr("YOU RAN INTO THE MONSTER ");
	ddwr("HE SHOVES YOU BACK")
	ddwr("");
	if( ddrandom(1, 2) == 2 )
	{
		ddmaintimeloop();
	}
	else
	{
		ddwr("YOU LOOSE 6 HIT POINT ");
		ddglobal['C'][0] = ddglobal['C'][0] - 6;
		ddmaintimeloop();
	}
}

/*
line 02413
*/
function ddranintogold()
{
	var locg = ddglobal['G'] + ddglobal['S'];
	var loch = ddglobal['H'] + ddglobal['T'];
	ddwr("AH......GOLD.......");
	ddglobal['G9'] = ddrandom(1, 500) + 10;
	ddwr(ddglobal['G9']+"PIECES");
	ddglobal['C'][7] = ddglobal['C'][7] + ddglobal['G9'];
	ddwr("GP= "+ddglobal['C'][7]);
	ddglobal['DA'][locg][loch] = 0;
	ddcheckforpoison();
	ddglobal['G'] = ddglobal['G'] + ddglobal['S'];
	ddglobal['H'] = ddglobal['H'] + ddglobal['T'];
	ddwr("DONE");
	ddmaintimeloop();

}

/*
line 02419
*/
function ddcheckforpoison()
{
	if( ddrandom(1, 100) < 20 )
	{
		ddwr("       POISON      ");
		ddglobal['C'][0] = ddglobal['C'][0] - ddrandom(1, 4);
		ddwr("HP= "+ddglobal['C'][0]);
	}
}

/*
line 02424
*/
function ddincreasestr()
{
	//the original code did not give a message
	ddwr("A STRANGE VAPOR");
	var locg = ddglobal['G'] + ddglobal['S'];
	var loch = ddglobal['H'] + ddglobal['T'];
	ddglobal['C'][1] = ddglobal['C'][1] + 1;
	ddglobal['DA'][locg][loch] = 0;
	ddcheckforpoison();
	ddglobal['G'] = ddglobal['G'] + ddglobal['S'];
	ddglobal['H'] = ddglobal['H'] + ddglobal['T'];
	ddwr("DONE");
	ddmaintimeloop();
}

/*
line 02426
*/
function ddincreasecon()
{
	//the original code did not give a message
	ddwr("A STRANGE VAPOR");
	var locg = ddglobal['G'] + ddglobal['S'];
	var loch = ddglobal['H'] + ddglobal['T'];
	ddglobal['C'][3] = ddglobal['C'][3] + 1;
	ddglobal['DA'][locg][loch] = 0;
	ddcheckforpoison();
	ddglobal['G'] = ddglobal['G'] + ddglobal['S'];
	ddglobal['H'] = ddglobal['H'] + ddglobal['T'];
	ddwr("DONE");
	ddmaintimeloop();
}

/*
03430
*/
function ddsearchforsecret()
{

	ddwr("SEARCH.........SEARCH...........SEARCH...........");
	if( ddrandom(1,40) < (ddglobal['C'][5] + ddglobal['C'][6]) )
	{
		var foundflag = 0;
		for(var M = -1; M <= 1; M++)
		{
			for(var N = -1; N <= 1; N++)
			{
				var locg = ddglobal['G'] + M;
				var loch = ddglobal['H'] + N;
				if(ddglobal['DA'][locg][loch] == 2)
				{
					foundflag = 1;
					ddwr("YES THERE IS A TRAP");
					ddwr("IT IS "+M+"VERTICALY  "+N+"HORAZONTALY FROM YOU");
					//need to look into what Z is about
					ddglobal['Z'] = 1;
				}
				else if(ddglobal['DA'][locg][loch] == 3)
				{
					foundflag = 1;
					ddwr("YES A DOOR");
					ddwr("IT IS AT "+M+"VERTICALY  "+N+"HORAZANTALY");
					//need to look into what Z is about
					ddglobal['Z'] = 1;
				}
			}
		}
		if( foundflag == 0 )
		{
			ddwr("NO NOT THAT YOU CAN TELL");
			ddmaintimeloop();
		}
		else
		{
			ddmaintimeloop();
		}
	}
	else
	{
		ddwr("NO NOT THAT YOU CAN TELL");
		ddmaintimeloop();
	}
}

/*
line 03640
*/
function ddequipweapon_pre()
{
	ddwr("WHICH WEAPON WILL YOU HOLD, NUM OF WEAPON ");
	ddwrgetinput('ddequipweapon');
}

/*
line 03650
*/
function ddequipweapon(cliinput)
{
	ddglobal['Y'] = cliinput;
	if(cliinput == 0)
	{
		//i think entering 0 is suppose to leave you empty handed
		//ddwr("O.K. YOU ARE NOW HOLDING A "+ddglobal['IS'][cliinput]);
		ddwr("YOU ARE NOW EMPTY HANDED");
		ddglobal['J'] = 0;
		ddmaintimeloop();
	}
	else if( (cliinput >= 1 ) && (cliinput <= 16) )
	{
		var itemfound = null;
		for(var M = 1; M <= ddglobal['X']; M++)
		{
			if(ddglobal['W'][M] == cliinput)
			{
				itemfound = M;
			}
		}
		if(itemfound != null)
		{
			ddwr("O.K. YOU ARE NOW HOLDING A "+ddglobal['IS'][cliinput]);
			ddglobal['J'] = cliinput;
			ddmaintimeloop();
		}
		else
		{
			ddwr("SORRY YOU DONT HAVE THAT ONE");
			ddequipweapon_pre();
		}
	}
	else
	{
		//we have unknown input
		ddequipment_pre();
	}
}

/*
line 03750
*/
function ddfightback()
{
	var weaponnumber = ddglobal['J'];
	ddwr("YOUR WEAPON IS "+ddglobal['IS'][weaponnumber]);
	if( ddglobal['K'] == 0 )
	{
		//no monster to fight
		//show command list again
		ddwr("YOU ATTACK THE DARKNESS");
		ddcommandlist_pre();
	}
	else
	{
		ddwr("MONSTER IS "+ddglobal['BS'][ddglobal['K']]);
		ddwr("HP="+ddglobal['B'][ddglobal['K']][3]);
		dddetermineweapon();
	}

}

/*
line 03800
a lot of characteristics of weapons is determined through code
*/
function dddetermineweapon()
{
	if( ddglobal['J'] == 0 )
	{
		//GOTO 04460
		ddbarehandedattack_pre();
	}
	else if( ddglobal['J'] == 1 )
	{
		//GOTO 04680
		ddswordattack();
	}
	else if( ddglobal['J'] == 2 )
	{
		//GOTO 04860
		ddtwohandattack();
	}
	else if( ddglobal['J'] == 3 )
	{
		//GOTO 05040
		dddaggerattack();
	}
	else if( ddglobal['J'] == 4 )
	{
		//GOTO 05270
		ddmaceattack();
	}
	else if( (ddglobal['J'] > 4) && (ddglobal['J'] < 15) )
	{
		//GOTO 03870
		//ranged?
		if( ddglobal['J'] == 5 )
		{
			//GOTO 05760
			//R3 = 10, R4 = (3/7), R5 = (5/11)
			dduniversalweaponattack(ddglobal['R1'], 10, ddglobal['R2'], 0, 0, (3/7), (5/11))
		}
		else if( ddglobal['J'] == 6 )
		{
			//BOWS
			//GOTO 05800
			dduniversalweaponattack(ddglobal['R1'], 15, ddglobal['R2'], 0, 0, (3/7), (5/11))
		}
		else if( ddglobal['J'] == 7 )
		{
			//ARROWS
			//GOTO 05840
			dduniversalweaponattack(ddglobal['R1'], 1.5, ddglobal['R2'], 0, 0, (1/7), (1/5))
		}
		else if( ddglobal['J'] == 8 )
		{
			//GOTO 05880
			dduniversalweaponattack(ddglobal['R1'], 4, ddglobal['R2'], 0, 0, (1/10), (1/8))
		}
		else if( ddglobal['J'] == 9 )
		{
			//GOTO 05920
			dduniversalweaponattack(ddglobal['R1'], 4, ddglobal['R2'], 0, 0, (1/7), (1/6))
		}
		else if( ddglobal['J'] == 10 )
		{
			//GOTO 05960
			dduniversalweaponattack(ddglobal['R1'], 3, ddglobal['R2'], 0, 0, (1/8), (1/5))
		}
		else if( ddglobal['J'] == 11 )
		{
			//GOTO 06000
			dduniversalweaponattack(ddglobal['R1'], 5, ddglobal['R2'], 0, 0, (1/9), (1/6))
		}
		else if( ddglobal['J'] == 12 )
		{
			//GOTO 06040
			dduniversalweaponattack(ddglobal['R1'], 8, ddglobal['R2'], 0, 0, (1/9), (1/4))
		}
		else if( ddglobal['J'] == 13 )
		{
			//SILVER CROSS
			//GOTO 06080
		}
		else if( ddglobal['J'] == 14 )
		{
			//GOTO 06120
		}
	}
	else if( ddglobal['J'] == 15 )
	{
		ddfoodattack_pre();
	}
	else if( ddglobal['J'] == 16 )
	{
		//THORS HAMMER!
		ddmjolnirattack();
	}
}

/*
line 06160
*/
function dduniversalweaponattack(currange, maxrange, hitres, wdam0, wdam1, wdam2, wdam3)
{
	if( currange > maxrange )
	{
		//GOTO 04710
		ddwr("HE IS OUT OF RANGE");
		ddmaintimeloop();
	}
	else
	{
		if( hitres == 0 )
		{
			ddwr("MISS");
			ddmaintimeloop();
		}
		else if( hitres == 1)
		{
			ddwr("HIT BUT NO DAMAGE");
			ddmaintimeloop();
		}
		else if( hitres == 2)
		{
			ddwr("HIT");
			var damage = parseInt(ddglobal['C'][1] * wdam2 );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
		else if( hitres == 3)
		{
			ddwr("CRITICAL HIT");
			var damage = parseInt(ddglobal['C'][1] * wdam3 );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
	}
}

/*
line 04460
*/
function ddbarehandedattack_pre()
{
	ddwr("DO YOU REALIZE YOU ARE BARE HANDED");
	//ddwr("DO YOU WANT TO MAKE ANOTHER CHOICE");
	ddwr("DO YOU WANT TO MAKE ANOTHER CHOICE (Y)ES (N)O");
	ddwrgetinput('ddbarehandedattack');
}

/*
line 04490
*/
function ddbarehandedattack(cliinput)
{
	ddglobal['QS'] = cliinput;
	if( (cliinput == 'Y') || (cliinput == 'YES') )
	{
		//give the player a free turn
		ddcommandlist_pre();
	}
	else
	{
		ddwr("O.K. PUNCH BITE SCRATCH HIT ........");
		//I dont know why the code searches 1 square around the character
		//here as it seems we could just use the R1 variable
		if( ddglobal['R1'] <= 1 )
		{
			if( ddrandom(1, 20) > ddglobal['B'][ddglobal['K']][2])
			{
				ddwr("GOOD A HIT");
				var damage = parseInt(ddglobal['C'][1] * (1/6) );
				ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
				ddwr("YOU DID "+damage+" DAMAGE");
				//ddcommandlist_pre();
				//The original code let the player get a free action
				//if they hit the monster
				ddmaintimeloop();
			}
			else
			{
				ddwr("TERRIBLE NO GOOD");
				ddmaintimeloop();
			}
		}
		else
		{
			ddwr("NO GOOD ONE");
			ddmaintimeloop();
		}
	}
}

/*
line 04680
*/
function ddswordattack()
{
	ddwr("SWING");
	ddrangeandhitcheck();
	if( ddglobal['R1'] < 2 )
	{
		if( ddglobal['R2'] == 0 )
		{
			ddwr("MISSED TOTALY");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 1 )
		{
			ddwr("NOT GOOD ENOUGH");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 2 )
		{
			ddwr("GOOD HIT");
			var damage = parseInt(ddglobal['C'][1] * (1/2) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 3 )
		{
			ddwr("CRITICAL HIT");
			var damage = parseInt(ddglobal['C'][1] * (4/5) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
	}
	else
	{
		ddwr("HE IS OUT OF RANGE");
		ddmaintimeloop();
	}
}

/*
line 04860
*/
function ddtwohandattack()
{
	ddwr("SWHNG");
	ddrangeandhitcheck();
	if( ddglobal['R1'] < 2.1 )
	{
		//GOTO 04910
		if( ddglobal['R2'] == 0 )
		{
			ddwr("MISSED TOTALY");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 1 )
		{
			ddwr("HIT BUT ? WELL ENOUGH");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 2 )
		{
			ddwr("HIT");
			var damage = parseInt( ddglobal['C'][1] * (5/7) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 3 )
		{
			ddwr("CRITICAL HIT");
			var damage = parseInt( ddglobal['C'][1] * (1) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
	}
	else
	{
		ddwr("HE IS OUT OF RANGE");
		ddmaintimeloop();
	}
}

/*
line 05040
*/
function dddaggerattack()
{
	ddrangeandhitcheck();
	if( ddglobal['R1'] > 5 )
	{
		//GOTO 04710
		ddwr("HE IS OUT OF RANGE");
		ddmaintimeloop();
	}
	else if( ddglobal['R1'] > 1 )
	{
		for(var M = 1; M <= ddglobal['X']; M++)
		{
			if( ddglobal['W'][M] == 3 )
			{
				ddglobal['W'][M] = 0;
				//this should break the loop and stop searching
				M = ddglobal['X'] + 1;
			}
		}
		ddglobal['J'] = 0;
		ddwr("YOU ARE NOW EMPTY HANDED");
		ddwr("YOU THROW YOUR DAGGER");
		dddaggerattackchances();
	}
	else if( ddglobal['R1'] <= 1 )
	{
		ddwr("SLASH");
		dddaggerattackchances();
	}
}

function dddaggerattackchances()
{
		if( ddglobal['R2'] == 0 )
		{
			ddwr("MISSED TOTALY");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 1 )
		{
			ddwr("HIT BUT NO DAMAGE");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 2 )
		{
			ddwr("HIT");
			var damage = parseInt( ddglobal['C'][1] * (1/4) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 3 )
		{
			ddwr("CRITICAL HIT");
			var damage = parseInt( ddglobal['C'][1] * (3/10) )
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
}

/*
line 05270
*/
function ddmaceattack()
{
	ddwr("SWING");
	ddrangeandhitcheck();
	if( ddglobal['R1'] < 2 )
	{
		//GOTO 04910
		if( ddglobal['R2'] == 0 )
		{
			ddwr("MISSED TOTALY");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 1 )
		{
			ddwr("HIT BUT ? WELL ENOUGH");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 2 )
		{
			ddwr("HIT");
			var damage = parseInt( ddglobal['C'][1] * (5/11) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 3 )
		{
			ddwr("CRITICAL HIT");
			var damage = parseInt( ddglobal['C'][1] * (4/9) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
	}
	else
	{
		ddwr("HE IS OUT OF RANGE");
		ddmaintimeloop();
	}
}

/*
line 03880
*/
function ddfoodattack_pre()
{
	ddwr("FOOD ???.... WELL O.K.");
	ddwr("IS IT TO (H)IT OR (D)ISTRACT");
	ddwrgetinput('ddfoodattack');
}

/*
line 03900
*/
function ddfoodattack(cliinput)
{
	ddglobal['QS'] = cliinput;
	if( (cliinput == 'H') || (cliinput == 'HIT') )
	{
		ddfoodhitattack();
	}
	else if( (cliinput == 'D') || (cliinput == 'DISTRACT') )
	{
		ddfooddistractattack_pre();
	}
	else
	{
		//unknown input
		ddwrgetinput('ddfoodattack');
	}
}

/*
line 04330
food used its own attack routine much like bare handed
I changed this to just use the generic ddrangeandhitcheck.
*/
function ddfoodhitattack()
{
	for(var M = 1; M <= ddglobal['X']; M++)
	{
		if( ddglobal['W'][M] == 15 )
		{
			ddglobal['W'][M] = 0;
			//this should break the loop and stop searching
			M = ddglobal['X'] + 1;
		}
	}
	ddglobal['J'] = 0;
	ddwr("YOU ARE NOW EMPTY HANDED");
	ddwr("PALLOOOOINK");
	ddrangeandhitcheck();
	if( ddglobal['R1'] < 10 )
	{
		//GOTO 04910
		if( ddglobal['R2'] == 0 )
		{
			ddwr("TOTAL MISS");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 1 )
		{
			ddwr("YOU HIT HIM BUT NOT GOOD ENOUGH");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 2 )
		{
			ddwr("HIT");
			var damage = parseInt( ddglobal['C'][1] * (1/8) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 3 )
		{
			ddwr("DIRECT HIT");
			var damage = parseInt( ddglobal['C'][1] * (1/6) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
	}
	else
	{
		ddwr("HE IS OUT OF RANGE");
		ddmaintimeloop();
	}
}

/*
New magic weapon
*/
function ddmjolnirattack()
{

	ddrangeandhitcheck();
	if( ddglobal['R1'] < 2 )
	{
		ddwr("SWING");
		if( ddglobal['R2'] == 0 )
		{
			ddwr("MISSED TOTALY");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 1 )
		{
			ddwr("GRAZING BLOW");
			var damage = parseInt( ddglobal['C'][1] * (1) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 2 )
		{
			ddwr("SOLID HIT");
			var damage = parseInt( ddglobal['C'][1] * (3/2) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 3 )
		{
			ddwr("BY THORS HAMMER");
			var damage = parseInt( ddglobal['C'][1] * (2) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddmaintimeloop();
		}
	}
	else
	{
		ddwr("THROW");
		if( ddglobal['R2'] == 0 )
		{
			ddwr("MISSED TOTALY");
			ddwr("THE HAMMER RETURNS TO YOUR HAND");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 1 )
		{
			ddwr("GRAZING BLOW");
			var damage = parseInt( ddglobal['C'][1] * (1) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddwr("THE HAMMER RETURNS TO YOUR HAND");
			//ddcommandlist_pre();
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 2 )
		{
			ddwr("SOLID HIT");
			var damage = parseInt( ddglobal['C'][1] * (3/2) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddwr("THE HAMMER RETURNS TO YOUR HAND");
			ddmaintimeloop();
		}
		else if( ddglobal['R2'] == 3 )
		{
			ddwr("BY THORS HAMMER");
			var damage = parseInt( ddglobal['C'][1] * (2) );
			ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
			ddwr("YOU DID "+damage+" DAMAGE");
			ddwr("THE HAMMER RETURNS TO YOUR HAND");
			ddmaintimeloop();
		}
		ddmaintimeloop();
	}
}





/*
line 06610
*/
function ddsavegame()
{
	//ddglobal['FILE'][7] = Array();
	var savearray = Array();

	savearray['D'] = ddglobal['D'];
	savearray['X'] = ddglobal['X'];
	savearray['J'] = ddglobal['J'];
	savearray['G'] = ddglobal['G'];
	savearray['H'] = ddglobal['H'];
	savearray['K'] = ddglobal['K'];

}

/*
line 08680
*/
function ddcastmagic()
{
	if( ddglobal['J'] != 0 )
	{
		//lose a turn!
		ddwr("YOU CANT USE MAGIC WITH WEAPON IN HAND");
		ddmaintimeloop();
	}
	else if( (ddglobal['CS'][0] == "CLERIC") )
	{
		ddwr("CLERICAL SPELL #");
		ddwrgetinput('ddcastcleric');
	}
	else if( (ddglobal['CS'][0] == "WIZARD") )
	{
		ddwr("SPELL #");
		ddwrgetinput('ddcastwizard');
	}
	else
	{
		//lose a turn!
		ddwr("YOU CANT TSE MAGIC YOUR NOT A M.U.");
		ddmaintimeloop();
	}
}

/*
line 08760
*/
function ddcastcleric(cliinput)
{
	ddglobal['Q'] = cliinput;
	cliinput = parseInt(cliinput);
	if( (cliinput >= 1) && (cliinput <= 9) )
	{
		var havespellflag = null;
		for(var M = 1; M <= ddglobal['X1']; M++)
		{
			if( cliinput == ddglobal['X2'][M] )
			{
				var havespellflag = M;
			}
		}
		if( havespellflag != null )
		{
			//GOTO 08830
			dddebug(havespellflag);
			dddebug(cliinput);
			dddebug("dddetermineclericspelleffect");
			dddetermineclericspelleffect(cliinput, havespellflag);
		}
		else
		{
			//lose a turn!
			ddwr("YOU DONT HAVE THAT SPELL");
			ddmaintimeloop();
		}
	}
	else
	{
		//we have unknown input
		ddwrgetinput('ddcastmagic');
	}
}

/*
line 08830
*/
function dddetermineclericspelleffect(spellnum, memnum)
{
	ddwr("YOU CAST A CLERIC SPELL");
	//ddwr("NOT IMPLEMENTED YET");
	if(spellnum == 1)
	{
		//GOTO 08950
		if( ddrandom(1, 3) > 1 )
		{
			ddwr("DONE");
			ddglobal['X2'][memnum] = 0;
			ddglobal['K1'] = -1;
		}
	}
	else if(spellnum == 2)
	{
		//GOTO 09040
		ddwr("CASTING");
		ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - 4;
		ddglobal['X2'][memnum] = 0;
	}
	else if(spellnum == 3)
	{
		//GOTO 09060
		ddwr("CASTING");
		ddglobal['C'][3] = ddglobal['C'][3] + 3;
		ddglobal['X2'][memnum] = 0;
	}
	else if(spellnum == 4)
	{
		//search for traps
		//Q = 2
		//GOTO 09090
		ddwr("CASTING");
		ddgenericsearchspell(3, 2);
		ddglobal['X2'][memnum] = 0;
	}
	else if(spellnum == 5)
	{
		//GOTO 09200
		ddwr("DONE");
		ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - 2;
		ddglobal['X2'][memnum] = 0;
	}
	else if(spellnum == 6)
	{
		//GOTO 09240
		ddwr("DONE");
		ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - 6;
		ddglobal['X2'][memnum] = 0;
	}
	else if(spellnum == 7)
	{
		//GOTO 09280
		ddwr("DONE");
		ddglobal['C'][3] = ddglobal['C'][3] + 3;
		ddglobal['X2'][memnum] = 0;
	}
	else if(spellnum == 8)
	{
		//search for secret doors
		//Q = 3
		//GOTO 09090
		ddwr("CASTING");
		ddgenericsearchspell(3, 3);
		ddglobal['X2'][memnum] = 0;
	}
	else if(spellnum == 9)
	{
		//GOTO 09720
		if( (ddglobal['K'] == 4 ) || ( ddglobal['K'] == 10 ) )
		{
			ddwr("DONE");
			//Just going to make the monster disappear instead of moving it
			ddwr("MONSTER FLED");
			ddmonsterfled();
		}
		else
		{
			ddwr("FAILED");
		}
	}
	else
	{
		ddwr("YOU DONT HAVE THAT SPELL");
	}
	ddmaintimeloop();
}

/*
line 09090
*/
function ddgenericsearchspell(range, tiletypenum)
{
		for(var M = -(range); M <= range; M++)
		{
			for(var N = -(range); N <= range; N++)
			{
				if( ddcheckplacementbounds(M, N) == true )
				{
					var locg = ddglobal['G'] + M;
					var loch = ddglobal['H'] + N;
					if( ddglobal['DA'][locg][loch] == tiletypenum )
					{
						ddwr("THERE IS ONE AT "+M+"LAT."+N+"LONG.");
					}
				}
			}
		}
}

function ddmonsterfled()
{
	ddglobal['K1'] = 0;
	ddglobal['DA'][ddglobal['F1']][ddglobal['F2']] = 0;
	ddglobal['F1'] = 0;
	ddglobal['F2'] = 0;
	//TODO implement code concering whether to reset monsters or not
	//ddmaintimeloop();
	//where to send code is handled by spellcasting code
	//or by main loop by using the K flag
	ddglobal['K'] = 0;
}

/*
line 09310
X3 must be the master wizard spell list count
X4 must be what the player has purchased
*/
function ddcastwizard(cliinput)
{
	ddglobal['Q'] = cliinput;
	if( (cliinput >= 1) && (cliinput <= 9) )
	{
		var havespellflag = null;
		for(var M = 1; M <= ddglobal['X3']; M++)
		{
			if( cliinput == ddglobal['X4'][M] )
			{
				var havespellflag = M;
			}
		}
		if( havespellflag != null )
		{
			//GOTO 09390
			dddeterminewizardspelleffect(cliinput, havespellflag);
		}
		else
		{
			//lose a turn!
			ddwr("YOU DONT HAVE THAT SPELL");
			ddmaintimeloop();
		}
	}
	else
	{
		//we have unknown input
	}
}

/*
line 09390
*/

function dddeterminewizardspelleffect(spellnum, memnum)
{
	ddwr("YOU CAST A WIZARD SPELL");
	//ddwr("NOT IMPLEMENTED YET");
	if(spellnum == 1)
	{
		//GOTO 09420
		//PUSH
		ddwr("GUST OF WIND HITS MONSTER");
		var damage = 0 + ddrandom(1, 2);
		ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
		ddwr("M-HP="+ddglobal['B'][ddglobal['K']][3]+"");
		ddmovemonsteraway();
		ddglobal['X2'][memnum] = 0;
		ddmaintimeloop();
	}
	else if(spellnum == 2)
	{
		//GOTO 09660
		//KIHL
		if( ddrandom(1, 3) > 1 )
		{
			ddwr("DONE");
			ddglobal['X2'][memnum] = 0;
			ddglobal['K1'] = -1;
		}
		else
		{
			ddwr("FAILED");
		}
		ddmaintimeloop();
	}
	else if(spellnum == 3)
	{
		//same as cleric spell
		//GOTO 09090
		//search for traps
		//Q = 2
		//GOTO 09800
		ddwr("CASTING");
		ddgenericsearchspell(3, 2);
		ddglobal['X2'][memnum] = 0;
		ddmaintimeloop();
	}
	else if(spellnum == 4)
	{
		//GOTO 09800
		//TELEPORT
		ddwr("INPUT X CO-ORDINATE");
		ddwrgetinput('ddteleportgetxcoordinate');
	}
	else if(spellnum == 5)
	{
		//GOTO 09860
		//CHANGE 1+0
		//REMOVE WALL
		ddwr("NOT IMPLEMENTED YET");
		ddmaintimeloop();
	}
	else if(spellnum == 6)
	{
		//GOTO 09950
		//MAGIC MISSILE #1
		//Q = 3
		ddwr("DONE");
		var damage = 3 + ddrandom(1, 11);
		ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
		ddglobal['X2'][memnum] = 0;
		ddwr("M-HP="+ddglobal['B'][ddglobal['K']][3]+"");
		ddmaintimeloop();
	}
	else if(spellnum == 7)
	{
		//GOTO 09950
		//MAGIC MISSILE #2
		//Q = 6
		ddwr("DONE");
		var damage = 6 + ddrandom(1, 11);
		ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
		ddglobal['X2'][memnum] = 0;
		ddwr("M-HP="+ddglobal['B'][ddglobal['K']][3]+"");
		ddmaintimeloop();
	}
	else if(spellnum == 8)
	{
		//MAGIC MISSILE #3
		//Q = 9
		ddwr("DONE");
		var damage = 9 + ddrandom(1, 11);
		ddglobal['B'][ddglobal['K']][3] = ddglobal['B'][ddglobal['K']][3] - damage;
		ddglobal['X2'][memnum] = 0;
		ddwr("M-HP="+ddglobal['B'][ddglobal['K']][3]+"");
		ddmaintimeloop();
	}
	else if(spellnum == 9)
	{
		//GOTO 09090
		//same as cleric spell
		//search for secret doors
		//Q = 3
		ddwr("CASTING");
		ddgenericsearchspell(3, 3);
		ddglobal['X2'][memnum] = 0;
		ddmaintimeloop();
	}
	else if(spellnum == 10)
	{
		//GOTO 09090
		//CHANGE 0+1
		//ADD WALL
		ddwr("NOT IMPLEMENTED YET");
		ddmaintimeloop();
	}
	else
	{
		ddwr("YOU DONT HAVE THAT SPELL");
		ddmaintimeloop();
	}
}

/*
line 09800
*/
function ddteleportgetxcoordinate(cliinput)
{
	ddglobal['U5'] = parseInt(cliinput);
	if( (cliinput >= 0) && (cliinput <= 25) )
	{
		ddwr("INPUT Y CO-ORDINATE 1 - 24");
		ddwrgetinput('ddteleportgetycoordinate');
	}
	else
	{
		ddwr("INPUT X CO-ORDINATE 1 - 24");
		ddwrgetinput('ddteleportgetxcoordinate');
	}
}

function ddteleportgetycoordinate(cliinput)
{
	ddglobal['U6'] = parseInt(cliinput);
	if( (cliinput >= 0) && (cliinput <= 25) )
	{
		ddtryteleport();
	}
	else
	{
		ddwrite("INPUT Y CO-ORDINATE 1 - 24");
		ddwrgetinput('ddteleportgetycoordinate');
	}
}

/*
line 09830
*/
function ddtryteleport()
{
	var U5 = ddglobal['U5'];
	var U6 = ddglobal['U6'];
	if( ddglobal['DA'][U5][U6] == 1 )
	{
		ddwr("YOU TELEPORTED INTO A WALL");
		ddwr("SORRY YOUR DEAD");
		ddendprogram();
	}
	else
	{
		//It would be better if this invoked the move function so that
		//traps, vapors, and other effects would happen.
		ddglobal['G'] = U5;
		ddglobal['H'] = U6;
		ddmaintimeloop();
	}
}

/*
line 09980
*/
function ddbuymagic()
{
	if( ddglobal['CS'][0] == 'CLERIC' )
	{
		//ddwr("DO YOU KNOW THE CHOICES ");
		ddwr("DO YOU KNOW THE CHOICES (Y)ES (N)O");
		ddwrgetinput('ddlistclericmagic');
	}
	else if( ddglobal['CS'][0] == 'WIZARD' )
	{
		ddwr("DO YOU KNOW THE SPELLS (Y)ES (N)O");
		ddwrgetinput('ddlistwizardmagic');
	}
	else
	{
		ddwr("YOU CANT BUY ANY");
		ddcommandlist_pre();
	}
}

/*
line 10030
*/
function ddlistclericmagic(cliinput)
{
	ddglobal['QS'] = cliinput;
	if( (cliinput == 'Y') || (cliinput == 'YES') )
	{
		ddwrgetinput('ddbuyclericmagic');
	}
	else
	{
		//ddwr("1-KILL-500  5-MAG. MISS. #1-100");
		//ddwr("2-MAG. MISS. #2-200  6-MAG. MISS. #3-300");
		//ddwr("3-CURE LHGHT #1-200  7-CURE LIGHT #2-1000");
		//ddwr("4-FIND ALL TRAPS-200  8-FIND ALL S.DOORS-200");
		//ddwr("INPUT # WANTED   NEG.NUM.TO STOP");
		for(var M = 1; M <= 8; M++)
		{
			ddwr("("+M+") - "+ddglobal['E1'][M]+" - "+ddglobal['E2'][M]);
		}
		ddwr("INPUT # WANTED   (0) TO STOP");
		ddwrgetinput('ddbuyclericmagic');
	}
}

/*
line 10100
*/
function ddbuyclericmagic(cliinput)
{
	cliinput = parseInt(cliinput);
	ddglobal['Q'] = cliinput;
	//TODO spell costs are set here
	//might want to move to init global
	ddglobal['X5'] = Array('skip0');
	ddglobal['X5'][1] = 500;
	ddglobal['X5'][2] = 200;
	ddglobal['X5'][3] = 200;
	ddglobal['X5'][4] = 200;
	ddglobal['X5'][5] = 100;
	ddglobal['X5'][6] = 300;
	ddglobal['X5'][7] = 1000;
	ddglobal['X5'][8] = 200;
	if(cliinput < 1)
	{
		ddlistcharacterclericspells();
	}
	else if (cliinput > 8)
	{
		//try again
		ddwr("INPUT # WANTED   (0) TO STOP");
		ddwrgetinput('ddbuyclericmagic');
	}
	else
	{
		//check if character can afford it
		if( (ddglobal['C'][7] - ddglobal['X5'][cliinput]) < 0 )
		{
			ddwr("COSTS TOO MUCH");
			ddwr("INPUT # WANTED   (0) TO STOP");
			ddwrgetinput('ddbuyclericmagic');
		}
		else
		{
			ddglobal['C'][7] = ddglobal['C'][7] - ddglobal['X5'][cliinput];
			ddwr("IT IS YOURS");
			ddglobal['X1'] = ddglobal['X1'] + 1;
			ddglobal['X2'][ddglobal['X1']] = cliinput;
			ddwr("INPUT # WANTED   (0) TO STOP");
			ddwrgetinput('ddbuyclericmagic');
		}
	}
}

/*
line 10290
*/
function ddlistcharacterclericspells()
{
	ddwr("YOUR SPELLS ARE");
	for(var M = 1; M <= ddglobal['X1']; M++)
	{
		if( ddglobal['X2'][M] != 0 )
		{
			ddwr("#"+ddglobal['X2'][M]);
		}
	}
	ddwr("DONE");
	ddcommandlist_pre();
}

/*
line 10360
*/
function ddlistwizardmagic(cliinput)
{
	ddglobal['QS'] = cliinput;
	if( (cliinput == 'Y') || (cliinput == 'YES') )
	{
		ddwr("#OF ONE YOU WANT   (0) TO STOP");
		ddwrgetinput('ddbuywizardmagic');
	}
	else
	{
		//ddwr("1-PUSH-75   6-M. M. #1-100");
		//ddwr("2-KIHL-500  7-M. M. #2-200");
		//ddwr("3-FIND TRAPS-200  8-M. M. #3-300");
		//ddwr("4-TELEPORT-750  9-FIND S.DOORS-200");
		//ddwr("5-CHANGE 1+0-600  10-CHANGE 0+1-600");
		//ddwr("#OF ONE YOU WANT  NEG.NUM.TO STOP");
		for(var M = 1; M <= 10; M++)
		{
			ddwr("("+M+")- "+ddglobal['E3'][M]+" - "+ddglobal['E4'][M]);
		}
		ddwr("#OF ONE YOU WANT   (0) TO STOP");
		ddwrgetinput('ddbuywizardmagic');
	}
}

/*
line 10450
*/
function ddbuywizardmagic(cliinput)
{
	cliinput = parseInt(cliinput);
	ddglobal['Q'] = cliinput;
	//TODO spell costs are set here
	//might want to move to init global
	ddglobal['X6'] = Array('skip0');
	ddglobal['X6'][1] = 75;
	ddglobal['X6'][2] = 500;
	ddglobal['X6'][3] = 200;
	ddglobal['X6'][4] = 750;
	ddglobal['X6'][5] = 600;
	ddglobal['X6'][6] = 100;
	ddglobal['X6'][7] = 200;
	ddglobal['X6'][8] = 300;
	ddglobal['X6'][9] = 200;
	ddglobal['X6'][10] = 600;
	if(cliinput < 1)
	{
		ddlistcharacterwizardspells();
	}
	else if (cliinput > 10)
	{
		//try again
		ddwr("#OF ONE YOU WANT   (0) TO STOP");
		ddwrgetinput('ddbuywizardmagic');
	}
	else
	{
		//check if character can afford it
		if( (ddglobal['C'][7] - ddglobal['X6'][cliinput]) < 0 )
		{
			ddwr("COSTS TOO MUCH");
			ddwr("#OF ONE YOU WANT   (0) TO STOP");
			ddwrgetinput('ddbuywizardmagic');
		}
		else
		{
			ddglobal['C'][7] = ddglobal['C'][7] - ddglobal['X6'][cliinput];
			ddwr("IT IS YOURS");
			ddglobal['X3'] = ddglobal['X3'] + 1;
			ddglobal['X4'][ddglobal['X3']] = cliinput;
			ddwr("#OF ONE YOU WANT   (0) TO STOP");
			ddwrgetinput('ddbuywizardmagic');
		}
	}
}

/*

*/
function ddlistcharacterwizardspells()
{
	ddwr("YOUR SPELLS ARE");
	for(var M = 1; M <= ddglobal['X3']; M++)
	{
		if( ddglobal['X4'][M] != 0 )
		{
			var spellindex = ddglobal['X4'][M];
			ddwr("#"+spellindex+" "+ddglobal['E3'][spellindex]);
			//ddwr("#"+ddglobal['X4'][M]);
		}
	}
	ddwr("DONE");
	ddcommandlist_pre();
}

/*
line 10830
*/
function ddbuyhp_pre()
{
	ddwr("HOW MANY 200 GP. EACH ");
	ddwrgetinput('ddbuyhp');
}

/*
line 10840
*/
function ddbuyhp(cliinput)
{
	cliinput = parseInt(cliinput);
	ddglobal['Q'] = cliinput;
	if( (cliinput >= 0) && (cliinput <= 999) )
	{
		var goldcost = (cliinput * 200);
		if( (ddglobal['C'][7] - goldcost) >= 0 )
		{
			ddglobal['C'][0] = ddglobal['C'][0] + cliinput;
			ddglobal['C'][7] = ddglobal['C'][7] - goldcost;
			ddwr("OK DONE");
			ddlistabilityscores();
		}
		else
		{
			ddwr("NO");
			ddbuyhp_pre();
		}
	}
	else
	{
		//unknown input
		ddwrgetinput('ddbuyhp');
	}
}

/*
line 10840
*/
function ddlistabilityscores()
{
	ddwr("HP= "+ddglobal['C'][0]);
	for(var M = 1; M <=7; M++)
	{
		ddwr(ddglobal['CS'][M]+" = "+ddglobal['C'][M]);
	}
	ddmaintimeloop();
}

/*
line 11000
*/
function ddgodmodemapedit_pre()
{
	ddwr("DNG");
	ddwrgetinput('ddgodmodecryptic');
}

/*
line 11010
*/
function ddgodmodecryptic(cliinput)
{
	ddglobal['I2'] = cliinput;
	ddwr("X,Y,C");
	ddwrgetinput('ddgodmodemapedit');
}

/*
line 11030
*/
function ddgodmodemapedit(cliinput)
{
	//need to detect 3 inputs and split them into 3 variables
	//TODO make code change map
	ddmaintimeloop();
}

/*
line 08290
*/
function ddmonsterdead()
{
	ddglobal['K1'] = 0;
	//give character the monsters gold
	ddglobal['C'][7] = ddglobal['C'][7] + ddglobal['B'][ddglobal['K']][6];
	ddwr("GOOD WORK YOU JUST KILLED A "+ddglobal['BS'][ddglobal['K']]);
	ddwr("AND GET "+ddglobal['B'][ddglobal['K']][6]+" GOLD PIECES");
	//clean up monster variables
	ddglobal['DA'][ddglobal['F1']][ddglobal['F2']] = 0;
	ddglobal['F1'] = 0;
	ddglobal['F2'] = 0;
	//TODO implement code concering whether to reset monsters or not
	//ddmaintimeloop();
	//instead of sending it back to ddmaintimeloop we use global
	//code should know what to do if K is 0
	ddglobal['K'] = 0;
}

/*
line 08160
*/
function ddplayerhurtbad()
{
	if( ddglobal['C'][0] < 1 )
	{
		if( ddglobal['C'][0] < 0 )
		{
			if( ddglobal['C'][3] < 9 )
			{
				ddwr("SORRY YOUR DEAD");
				ddendprogram();
			}
			else
			{
				ddglobal['C'][3] = ddglobal['C'][3] - 2;
				ddglobal['C'][0] = ddglobal['C'][0] + 1;
				ddplayerhurtbad();
			}
		}
		else
		{
			ddwr("WATCH IT H.P.="+ddglobal['C'][0]);
		}
	}
	//should return to ddmaintimeloop right where it was called
}

/*
line 07830
*/
function ddwanderingmonster()
{
	//loop 50 times then loop over each monster
	for(var Z7 = 1; Z7 <= 50; Z7++)
	{
		for(var M = 1; M <= 10; M++)
		{
			if( (ddglobal['B'][M][5] >= 1 ) && ( ddrandom(1, 1000) > 925 ) )
			{
				if( ( M == 5) && ( ddrandom(1, 10) > 3) )
				{
					//When we are dealing with the Balrog
					//Make it more rare to appear
				}
				else
				{
					dddebug("MONSTER PLACEMENT ROUTINE");
					//GOTO 08000
					ddtryplacemonster(M);
					ddwr(ddglobal['BS'][M]+" at ("+ddglobal['F1']+","+ddglobal['F2']+")");
					ddglobal['I9'] = 0;
					return;
				}
			}
		}
	}
}

/*
line 08000
This is a doozy of loops.
It is going to keep trying and trying to find a spot.
Perhaps it would be better to rewrite this to give us the entire
list of 0 of the dungeon in the grid and then just randomly pick
one of those 0
*/
function ddtryplacemonster(monsternumber)
{
	ddglobal['K'] = monsternumber;
	ddglobal['M1'] = ddrandom(1, 7) + 1;
	var M1 = ddglobal['M1'];
	for(var M = -M1; M <= M1; M++)
	{
		for(var N = -M1; N <= M1; N++)
		{
			//skip over locations within 2 squares of character
			if( (Math.abs(M) > 2) && (Math.abs(N) > 2) )
			{
				if( ddcheckplacementbounds(M, N) == true )
				{
					if( ddrandom(1,10) > 7 )
					{
						var locg = ddglobal['G'] + M;
						var loch = ddglobal['H'] + N;
						dddebug("locg="+locg);
						dddebug("loch="+loch);
						if( ddglobal['DA'][locg][loch] == 0 )
						{
							dddropinthemonster(monsternumber, locg, loch);
							//the original code actually goes back to 07000
							return;
						}
					}
				}
			}
		}
	}
	//Hopefully we never get here but if we do then we try again
	//We should put some code here to only try 100 times or such
	ddtryplacemonster(monsternumber);
}

/*
line 08030
*/
function ddcheckplacementbounds(M, N)
{
	//The original code used this to place monsters
	//Reused this for checking map edges.
	//The old code would not let monsters on 0
	var spotcheck = true;
	if( (ddglobal['G'] + M) < 0 )
	{
		spotcheck = false;
	}
	if( (ddglobal['G'] + M) > 25 )
	{
		spotcheck = false;
	}
	if( (ddglobal['H'] + N) < 0 )
	{
		spotcheck = false;
	}
	if( (ddglobal['H'] + N) > 25 )
	{
		spotcheck = false;
	}
	return spotcheck;
}

/*
line 08110
*/
function dddropinthemonster(monsternumber, locg, loch)
{
	ddglobal['DA'][locg][loch] = 5;
	ddglobal['F1'] = locg;
	ddglobal['F2'] = loch;
}

/*
line 03050
*/
function ddranintomonster()
{
	ddwr("YOU RAN INTO THE MONSTER ");
	ddwr("HE SHOVES YOU BACK");
	ddwr("");
	if( ddrandom(1, 2) == 2 )
	{
		ddwr("YOU LOOSE 6 HIT POINT ");
		ddglobal['C'][0] = ddglobal['C'][0] - 6;
	}
	ddmaintimeloop();
}

/*
line 07050
*/
function ddequipmentshoptile_pre()
{
	ddwr("WANT TO BUY MORE EQUIPMENT");
	ddwrgetinput('ddequipmentshoptile');
}

/*
line 07090
*/
function ddequipmentshoptile(cliinput)
{
	ddglobal['QS'] = cliinput
	if( (cliinput == 'Y') || (cliinput == 'YES') )
	{
		//GOTO 00830
		ddbuyingweapons_pre();
	}
	else if( (cliinput == 'N') || (cliinput == 'NO') )
	{

	}
	else
	{
		//unknown input
		ddwrgetinput('ddequipmentshoptile');
	}
}

/*
line 08410
*/
function ddrangeandhitcheck()
{
	//ddglobal['R1'] = null;
	var monsterflag = false;
	for(var M = -25; M <= 25; M++)
	{
		for(var N = -25; N <= 25; N++)
		{
			var locg = ddglobal['G'] + M;
			var loch = ddglobal['H'] + N;
			if( (locg > 25) || (locg < 0) || (loch > 25) || (loch < 0) )
			{
				//Skip
				//This mimics original code
			}
			else
			{
				if( ddglobal['DA'][locg][loch] == 5 )
				{
					monsterflag = true;
					ddsetmonsterrange(M, N);
				}
			}
		}
	}
	if( monsterflag == false)
	{
		ddglobal['R1'] = 1000;
	}
	ddrangetypecheckset();
}

/*
line 08520
*/
function ddsetmonsterrange(monm, monn)
{
	ddglobal['R8'] = monm;
	ddglobal['R9'] = monn;
	ddglobal['R1'] = Math.sqrt( (monm * monm) + (monn * monn) );
}

/*
line 08420
R1 is distance between character and monster
R2 is the degree of hit, miss, good, critical
setting R2 to 1, 2, or 3
*/
function ddrangetypecheckset()
{
	if( ddglobal['R1'] == 1000 )
	{
		//this is not needed.
	}
	else
	{
		//man this needs be redone. It can be confusing
		//R1 should be set by ddsetmonsterrange by now

	}
	if( ddrandom(1, 20) > 18 )
	{
		//GOTO 08620
		ddglobal['R2'] = 3;
	}
	else if( ddrandom(1, 20) > ddglobal['B'][ddglobal['K']][2] - (ddglobal['C'][2] / 3) )
	{
		//GOTO 08640
		ddglobal['R2'] = 2;
	}
	else if( ddrandom(1,200) > 170 )
	{
		//GOTO 08660
		ddglobal['R2'] = 1;
	}
}

/*
line 07600
*/
function ddmonsterisclose()
{
	ddwr(ddglobal['BS'][ddglobal['K']]+" WATCH IT");
	var armorfound = 6;
	for(var M = 1; M <= ddglobal['X']; M++)
	{
		if( ddglobal['W'][M] == 10 )
		{
			//character has plate mail
			//GOTO 07720
			//ddglobal['A1'] = 20 + ddglobal['C'][2];
			if(armorfound < 20)
			{
				armorfound = 20;
			}
		}
		else if( ddglobal['W'][M] == 9 )
		{
			//GOTO 07700
			//ddglobal['A1'] = 16 + ddglobal['C'][2];
			if(armorfound < 16)
			{
				armorfound = 16;
			}
		}
		else if( ddglobal['W'][M] == 8 )
		{
			//GOTO 07680
			//ddglobal['A1'] = 12 + ddglobal['C'][2];
			if(armorfound < 12)
			{
				armorfound = 12;
			}
		}
		else
		{
			//ddglobal['A1'] = 6 + ddglobal['C'][2];
		}
	}
	ddglobal['A1'] = armorfound + ddglobal['C'][2];
	if( ddrandom(1, 40) > ddglobal['A1'] )
	{
		//GOTO 07790
		ddwr("MONSTER SCORES A HIT");
		var maxdamage = ddglobal['B'][ddglobal['K']][2];
		var damage = ddrandom(1, maxdamage);
		ddglobal['C'][0] = ddglobal['C'][0] - damage;
		ddwr("MONSTER DID "+damage+" DAMAGE");
		ddwr("H.P.="+ddglobal['C'][0]);
		//GOTO 07000
		//Wont this allow the monster to go again?
	}
	else if( ddrandom(1, 2) > 1 )
	{
		ddwr("HE HIT YOU BUT NOT GOOD ENOUGH");
		//GOTO 07000
		//Wont this allow the monster to go again?
	}
	else
	{
		ddwr("HE MISSED");
		//GOTO 01590
		//So if the monster misses the player gets to go
	}
}

/*
line 07210
*/
function ddmovemonstercloser()
{
	//R8 and R9 are set in the ddsetmonsterrange
	//which should have run by now
	//note that they are the distance from the character
	//not the DA dungeon coordinates
	var absr8 = Math.abs(ddglobal['R8']);
	var absr9 = Math.abs(ddglobal['R9']);
	if(absr8 > absr9)
	{
		//GOTO 07260
		ddglobal['F5'] = -(ddglobal['R8'] / absr8);
		ddglobal['F6'] = 0;
	}
	else
	{
		ddglobal['F5'] = 0;
		ddglobal['F6'] = -(ddglobal['R9'] / absr9);
	}
	if( (ddglobal['G'] == (ddglobal['F1'] + ddglobal['F5']) ) && 
	(ddglobal['H'] == ddglobal['F2'] + ddglobal['F6']) )
	{
		//Do not want monster moving into player space
	}
	else
	{
		//This is not in the original code
		var oldxcoordinate = ddglobal['F1'];
		var oldycoordinate = ddglobal['F2'];
	
		//loop through all the dungeon tile types
		for(var Q = 0; Q <= 8 ; Q++)
		{
			if( (Q != 1) && (Q != 5) )
			{
				var xcoordinate = ddglobal['F1'] + ddglobal['F5'];
				var ycoordinate = ddglobal['F2'] + ddglobal['F6'];
				if( !ddcheckdungeonbounds(xcoordinate, ycoordinate) )
				{
					if( ddglobal['DA'][xcoordinate][ycoordinate] == Q )
					{
						dddebug("ddtrymonstermovenewtile");
						ddtrymonstermovenewtile(Q);
					}
				}
			}
		}
		//This is not in the original code
		if( (ddglobal['F1'] == oldxcoordinate) && (ddglobal['F2'] == oldycoordinate) )
		{
			ddglobal['I9'] = ddglobal['I9'] + 1;
		}
		else
		{
			ddglobal['I9'] = 0;
		}
	}
}

function ddmovemonsteraway()
{
	//R8 and R9 are set in the ddsetmonsterrange
	//which should have run by now
	//note that they are the distance from the character
	//not the DA dungeon coordinates
	var absr8 = Math.abs(ddglobal['R8']);
	var absr9 = Math.abs(ddglobal['R9']);
	if(absr8 > absr9)
	{
		//GOTO 07260
		ddglobal['F5'] = +(ddglobal['R8'] / absr8);
		ddglobal['F6'] = 0;
	}
	else
	{
		ddglobal['F5'] = 0;
		ddglobal['F6'] = +(ddglobal['R9'] / absr9);
	}
	if( (ddglobal['G'] == (ddglobal['F1'] + ddglobal['F5']) ) && 
	(ddglobal['H'] == ddglobal['F2'] + ddglobal['F6']) )
	{
		//Do not want monster moving into player space
	}
	else
	{
		//This is not in the original code
		var oldxcoordinate = ddglobal['F1'];
		var oldycoordinate = ddglobal['F2'];
		//loop through all the dungeon tile types
		for(var Q = 0; Q <= 8 ; Q++)
		{
			if( (Q != 1) && (Q != 5) )
			{
				var xcoordinate = ddglobal['F1'] + ddglobal['F5'];
				var ycoordinate = ddglobal['F2'] + ddglobal['F6'];
				if( !ddcheckdungeonbounds(xcoordinate, ycoordinate) )
				{
					if( ddglobal['DA'][xcoordinate][ycoordinate] == Q )
					{
						dddebug("ddtrymonstermovenewtile");
						ddtrymonstermovenewtile(Q);
					}
				}
			}
		}
	}
}

/*
line 07300
*/
function ddcheckdungeonbounds(xcoordinate, ycoordinate)
{
	var outboundflag = false;
	if( xcoordinate < 0)
	{
		outboundflag = true;
	}
	if( xcoordinate > 25)
	{
		outboundflag = true;
	}
	if( ycoordinate < 0)
	{
		outboundflag = true;
	}
	if( ycoordinate > 25)
	{
		outboundflag = true;
	}
}

/*
line 07340
*/
function ddtrymonstermovenewtile(dungeontiletype)
{
  dddebug("dungeontiletype="+dungeontiletype);
	if( dungeontiletype == 0 )
	{
		ddmonstermovesimple();
	}
	else if( dungeontiletype == 2 )
	{
		ddmonstermovetrap();
	}
	else if( (dungeontiletype == 3) || (dungeontiletype == 4) )
	{
		ddmonstermovedoor();
	}
	else if( (dungeontiletype == 6) || (dungeontiletype == 7) || (dungeontiletype == 8) )
	{
		ddmonstermovesimple();
	}
	else
	{

	}
	//the original code would update monster range
}

/*
line 07430
*/
function ddmonstermovesimple()
{
  dddebug("ddmonstermovesimple");
	//change old space to empty space
	ddglobal['DA'][ddglobal['F1']][ddglobal['F2']] = 0;
	ddglobal['F1'] = ddglobal['F1'] + ddglobal['F5'];
	ddglobal['F2'] = ddglobal['F2'] + ddglobal['F6'];
	//change new space to monster space
	ddglobal['DA'][ddglobal['F1']][ddglobal['F2']] = 5;
}

/*
line 07530
*/
function ddmonstermovetrap()
{
	ddwr("GOOD WORK  YOU LED HIM INTO A TRAP");
	ddglobal['K1'] = -1;
	ddglobal['B'][ddglobal['K']][6] = 0;
	//original code GOTO 07000
	//okay, 07000 would have checked for K1 and said monster died
	//just do that here instead
	ddmonsterdead();
}

/*
line 07380
Tricky because you dont want the monster to end up on the door
*/
function ddmonstermovedoor()
{
	var xcoordinate = ddglobal['F1'] + (ddglobal['F5'] * 2);
	var ycoordinate = ddglobal['F2'] + (ddglobal['F6'] * 2);
	if( ddglobal['DA'][xcoordinate][ycoordinate] == 0 )
	{
		ddglobal['F5'] = ddglobal['F5'] * 2;
		ddglobal['F6'] = ddglobal['F6'] * 2;
		//monster distance to move is set to 2 spaces
		//send them to movesimple
		ddmonstermovesimple();
	}
	//The original code would GOTO 07510 if no empty space was found
	//just returning to normal code flow instead
}






















/*
utility functions
*/

function ddwr(txtscalar)
{
	consoleobj.innerHTML = consoleobj.innerHTML + txtscalar + "\n";
	consoleobj.scrollTop = consoleobj.scrollHeight;
}

function dddebug(txtscalar)
{
	//uncomment for debug statements
	//ddwr(txtscalar);
}

function ddwrgetinput(passfunctionname)
{
	passthru = passfunctionname;
	if(commandobj.value)
	{
		commandobj.value = '';
	}
	commandobj.focus();
}

function ddupdatemappad(mapstring)
{
	mappadobj.innerHTML = mapstring;
}

function ddcliinterpreter(inputobj)
{
	var cliinput = '';
	if(inputobj.value)
	{
		cliinput = inputobj.value;
		cliinput = cliinput.toUpperCase();
	}
	//TODO possibly set inputobj.value to empty string
	//WHY? to prevent multiple calls
	//DANGER WIL ROBINSON
	if(passthru != '')
	{
		var execcom = passthru+'("'+cliinput+'")';
		eval(execcom);
	}
	//LATER remove eval and write out by hand for security
	if(passthru == 'ddinstruction')
	{
		//ddinstruction(cliinput);
	}
	else if(passthru == '')
	{

	}
}

/*
Does not use low right now. Will improve it if needed.
*/
function ddrandom(low, high)
{
	var randomnumber = Math.floor((Math.random() * high) + 1);
	return randomnumber;
}

/*
Throw error to end program
*/
function ddendprogram()
{
	passthru = '';
	throw new Error("Program has terminated");
}

/*
global memory
I wanted to keep the original 1 to n loops instead of adjusting them to 0.
But javascript starts counting at 0 so keep that in mind.
*/
function ddinitglobalmemory()
{
	ddglobal = Array();
	ddglobal['CS'] = Array('skip0');
	ddglobal['CS'][1] = "STR";
	ddglobal['CS'][2] = "DEX";
	ddglobal['CS'][3] = "CON";
	ddglobal['CS'][4] = "CHAR";
	ddglobal['CS'][5] = "WIS";
	ddglobal['CS'][6] = "INT";
	ddglobal['CS'][7] = "GOLD";

	//ddglobal['IS'] = Array('skip0');
	//making element 0 say BARE HANDS
	ddglobal['IS'] = Array('BARE HANDS');
	ddglobal['P'] = Array('skip0');

	var itemlist = Array
	(
		"SWORD",10,"2-H-SWORD",15,"DAGGER",3,"MACE",5,
		"SPEAR",2,"BOW",25,"ARROWS",2,"LEATHER MAIL",15,
		"CHAIN MAIL",30,"TLTE MAIL",50,"ROPE",1,"SPIKES",1,
		"FLASK OF OIL",2,"SILVER CROSS",25,"SPARE FOOD",5,
		"MJOLNIR",960
	);
	//IS is item array of names
	//P is item array of prices
	for(var M = 1; M <= 16; M++)
	{
		var j = (M * 2) - 2;
		var k = j + 1;

		ddglobal['IS'][M] = itemlist[j];
		ddglobal['P'][M] = itemlist[k];
	}
	//X is count of bought items
	//W is an array of item numbers bought by character
	ddglobal['X'] = 0;
	ddglobal['W'] = Array('skip0');
	//DA is the current dungeon being played DA was just D(0,0) in the original
	ddglobal['DA'] = Array();
	//FILE replaces the file routines in the original
	//TODO change dddungeondata1 to 2, 3, 4 etc...
	ddglobal['FILE'] = Array();
	ddglobal['FILE'][0] = Array();
	ddglobal['FILE'][1] = dddungeondata1();
	ddglobal['FILE'][2] = dddungeondata2();
	ddglobal['FILE'][3] = dddungeondata3();
	ddglobal['FILE'][4] = dddungeondata4();
	ddglobal['FILE'][5] = dddungeondata5();
	ddglobal['FILE'][6] = dddungeondata6();
	//G is row location
	//H is column location
	ddglobal['G'] = ddrandom(1, 23) + 1;
	ddglobal['H'] = ddrandom(1, 23) + 1;
	//K is if there is a monster to fight or not
	ddglobal['K'] = 0;
	//FILE 7 is to save the game
	ddglobal['FILE'][7] = Array();
	//J is what weapon is in hand
	ddglobal['J'] = 0;
	//X1 is the count of purchased cleric spells
	ddglobal['X1'] = 0;
	//X2 is an array that holds the spell number
	ddglobal['X2'] = Array('skip0');
	//enchancement idea to put all spells into arrays
	//TODO replace ddlistclericmagic with this data
	ddglobal['E1'] = Array('skip0');
	ddglobal['E1'][1] = "KILL";
	ddglobal['E1'][2] = "MAG. MISS. #2";
	ddglobal['E1'][3] = "CURE LHGHT #1";
	ddglobal['E1'][4] = "FIND ALL TRAPS";
	ddglobal['E1'][5] = "MAG. MISS. #1";
	ddglobal['E1'][6] = "MAG. MISS. #3";
	ddglobal['E1'][7] = "CURE LIGHT #2";
	ddglobal['E1'][8] = "FIND ALL S.DOORS";
	ddglobal['E2'] = Array('skip0');
	ddglobal['E2'][1] = 500;
	ddglobal['E2'][2] = 200;
	ddglobal['E2'][3] = 200;
	ddglobal['E2'][4] = 200;
	ddglobal['E2'][5] = 100;
	ddglobal['E2'][6] = 300;
	ddglobal['E2'][7] = 1000;
	ddglobal['E2'][8] = 200;
	//X3 is the count of purchased wizard spells
	ddglobal['X3'] = 0;
	//X4 is an array that holds the spell number
	ddglobal['X4'] = Array('skip0');
	//enchancement idea to put all spells into arrays
	//TODO replace ddlistwizardmagic with this data
	ddglobal['E3'] = Array('skip0');
	ddglobal['E3'][1] =  "PUSH";
	ddglobal['E3'][2] =  "KIHL";
	ddglobal['E3'][3] =  "FIND TRAPS";
	ddglobal['E3'][4] =  "TELEPORT";
	ddglobal['E3'][5] =  "CHANGE 1+0";
	ddglobal['E3'][6] =  "M. M. #1";
	ddglobal['E3'][7] =  "M. M. #2";
	ddglobal['E3'][8] =  "M. M. #3";
	ddglobal['E3'][9] =  "FIND S.DOORS";
	ddglobal['E3'][10] = "CHANGE 0+1";
	ddglobal['E4'] = Array('skip0');
	ddglobal['E4'][1] = 75;
	ddglobal['E4'][2] = 500;
	ddglobal['E4'][3] = 200;
	ddglobal['E4'][4] = 750;
	ddglobal['E4'][5] = 600;
	ddglobal['E4'][6] = 100;
	ddglobal['E4'][7] = 200;
	ddglobal['E4'][8] = 300;
	ddglobal['E4'][9] = 200;
	ddglobal['E4'][10] = 600;
	//K1 is if a monster is active or dead
	ddglobal['K1'] = 0;
	//BS is monster name
	//B is monster stats
	//B[1] is does monster exist
	//B[2] is armor class and max damage
	//B[3] is hit points
	//B[5] is gold
	ddglobal['BS'] = Array('skip0');
	ddglobal['B'] = Array('skip0');
	//These are the original monster values
	var monsterlist = Array
	(
		"MAN",         1,13,26,1,1,500,
		"GOBLIN",      2,13,24,1,1,600,
		"TROLL",       3,15,35,1,1,1000,
		"SKELETON",    4,22,12,1,1,50,
		"BALROG",      5,18,110,1,1,5000,
		"OCHRE JELLY", 6,11,20,1,1,0,
		"GREY OOZE",   7,11,13,1,1,0,
		"GNOME",       8,13,30,1,1,100,
		"KOBOLD",      9,15,16,1,1,500,
		"MUMMY",      10,16,30,1,1,100
	);
	//These are easier monsters to fight
	var monsterlist = Array
	(
		"MAN",         1,10,16,1,1,500,
		"GOBLIN",      2,16,14,1,1,600,
		"TROLL",       3,14,24,1,1,1000,
		"SKELETON",    4,12,12,1,1,50,
		"BALROG",      5,18,42,1,1,5000,
		"OCHRE JELLY", 6,10,20,1,1,0,
		"GREY OOZE",   7,10,13,1,1,0,
		"GNOME",       8,16,10,1,1,500,
		"KOBOLD",      9,12,12,1,1,200,
		"MUMMY",      10,16,30,1,1,100
	);
	for(var M = 1; M <= 10; M++)
	{
		ddglobal['B'][M] = Array();
		var j = (M * 7) - 7;

		ddglobal['BS'][M] = monsterlist[j];
		ddglobal['B'][M][1] = monsterlist[(j + 1)];
		ddglobal['B'][M][2] = monsterlist[(j + 2)];
		ddglobal['B'][M][3] = monsterlist[(j + 3)];
		ddglobal['B'][M][4] = monsterlist[(j + 4)];
		ddglobal['B'][M][5] = monsterlist[(j + 5)];
		ddglobal['B'][M][6] = monsterlist[(j + 6)];
		//original code rearranged array
		ddglobal['B'][M][4] = ddglobal['B'][M][3];
		ddglobal['B'][M][5] = ddglobal['B'][M][6];
		ddglobal['B'][M][1] = 1;
	}
	//These are the coordinates on the dungeon of the monster
	//See ddplacemonster()
	ddglobal['F1'] = null;
	ddglobal['F2'] = null;
	//J6 is a flag that controls whether to continously reuse monsters
	ddglobal['J6'] = 0;
	//R8 and R9 are the location coordinates of any spawned monster
	ddglobal['R8'] = null;
	ddglobal['R9'] = null;
	//I9 keeps track of how long the monster has not done anything
	ddglobal['I9'] = 0;
}

function dddisplaymonster()
{
	for(var M = 1; M <= 10; M++)
	{
		ddwr(ddglobal['BS'][M] + ddglobal['B'][M][1]);
	}
}

function dddungeondata1()
{
	var duarray = Array();
	var durow = Array();
	var ducol = Array();
durow[0]  = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
durow[1]  = "1,6,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,6,2,1,1,1,6,1";
durow[2]  = "1,0,1,4,1,1,1,0,1,0,1,0,4,0,1,0,1,6,1,1,0,0,1,0,0,1";
durow[3]  = "1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,6,2,4,0,0,3,0,0,1";
durow[4]  = "1,0,1,6,0,0,1,0,4,0,1,0,1,0,1,0,1,6,1,1,0,0,3,0,0,1";
durow[5]  = "1,4,1,1,0,0,1,3,1,4,1,0,1,4,1,0,1,0,1,0,0,1,1,1,0,1";
durow[6]  = "1,0,0,0,0,0,2,0,0,0,7,0,0,0,0,0,1,1,1,1,1,1,0,1,0,1";
durow[7]  = "1,0,1,3,1,4,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,2,1,0,1";
durow[8]  = "1,0,1,6,1,0,1,1,1,0,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,1";
durow[9]  = "1,0,1,6,1,0,0,1,0,0,1,4,1,1,1,0,1,0,0,0,0,0,4,0,0,1";
durow[10] = "1,0,1,3,1,0,0,4,0,0,4,0,1,6,1,0,1,0,1,1,0,1,1,1,3,1";
durow[11] = "1,0,1,0,1,0,0,1,0,0,1,0,1,2,1,2,1,0,0,1,0,3,0,0,0,1";
durow[12] = "1,0,1,0,1,0,1,1,1,2,1,0,1,4,1,0,1,1,1,1,4,1,0,6,6,1";
durow[13] = "1,0,0,2,4,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,3,0,0,0,1";
durow[14] = "1,0,1,4,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,0,1,1,1,3,1";
durow[15] = "1,0,1,6,1,6,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1";
durow[16] = "1,0,1,0,0,0,1,0,1,2,1,0,1,0,1,2,1,2,0,0,2,0,1,0,6,1";
durow[17] = "1,0,1,0,0,0,1,0,1,6,1,2,1,0,1,0,1,0,1,0,0,0,1,0,0,1";
durow[18] = "1,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,4,1";
durow[19] = "1,0,0,0,6,0,3,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1";
durow[20] = "1,0,0,0,0,0,1,0,0,0,0,0,0,6,0,0,0,3,0,0,0,7,0,0,0,1";
durow[21] = "1,0,1,4,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1";
durow[22] = "1,0,1,0,1,0,0,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1";
durow[23] = "1,0,1,1,1,2,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1";
durow[24] = "1,0,4,6,1,6,0,1,0,0,0,0,4,0,1,0,1,0,0,4,0,0,0,0,0,1";
durow[25] = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
	for(var M = 0; M <= 25; M++)
	{
		ducolumn = durow[M].split(',');
		duarray[M] = ducolumn;
	}
	return duarray;
}

function dddungeondata2()
{
	var duarray = Array();
	var durow = Array();
	var ducol = Array();
durow[0]  = "1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1";
durow[1]  = "1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,7,1,1,1,0,1";
durow[2]  = "1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1";
durow[3]  = "1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,6,0,1,0,0,1";
durow[4]  = "1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1";
durow[5]  = "1,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,1";
durow[6]  = "1,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,1,1,1,0,1,0,1";
durow[7]  = "1,0,1,0,1,0,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1";
durow[8]  = "1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,1,0,0,1,1,0,1";
durow[9]  = "1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,1";
durow[10] = "1,0,1,4,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1";
durow[11] = "1,0,1,0,1,0,0,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1";
durow[12] = "1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,1,0,0,0,7,0,1";
durow[13] = "1,0,0,7,3,6,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1";
durow[14] = "1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,1,1,1,0,1";
durow[15] = "1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1";
durow[16] = "1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,2,0,1,0,0,1";
durow[17] = "1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1";
durow[18] = "1,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,1";
durow[19] = "1,0,0,0,7,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1";
durow[20] = "1,0,0,0,0,0,1,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,1";
durow[21] = "1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,1,0,0,0,0,0,1";
durow[22] = "1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,1";
durow[23] = "1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1";
durow[24] = "1,0,1,0,1,6,0,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1";
durow[25] = "1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,1,0,0,0,0,0,1";
	for(var M = 0; M <= 25; M++)
	{
		ducolumn = durow[M].split(',');
		duarray[M] = ducolumn;
	}
	return duarray;
}

function dddungeondata3()
{
	var duarray = Array();
	var durow = Array();
	var ducol = Array();
durow[0]  = "1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1";
durow[1]  = "1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,7,1,1,1,0,1";
durow[2]  = "1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1";
durow[3]  = "1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,6,0,0,1,0,1";
durow[4]  = "1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1";
durow[5]  = "1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,0,0,0,1,0,1,0,1";
durow[6]  = "1,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,0,1";
durow[7]  = "1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,4,0,1,0,1";
durow[8]  = "1,0,4,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1";
durow[9]  = "1,0,1,0,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1";
durow[10] = "1,0,1,1,1,0,1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1";
durow[11] = "1,0,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,0,1";
durow[12] = "1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,1";
durow[13] = "1,0,0,7,1,6,1,0,0,0,0,0,1,6,0,0,1,0,0,1,0,1,0,1,0,1";
durow[14] = "1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1";
durow[15] = "1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,0,1";
durow[16] = "1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,2,1,0,0,0,1";
durow[17] = "1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1";
durow[18] = "1,2,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1";
durow[19] = "1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1";
durow[20] = "1,0,0,0,0,0,1,0,0,0,0,0,0,6,0,1,0,0,0,0,0,1,0,0,0,1";
durow[21] = "1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,0,0,0,1";
durow[22] = "1,0,1,0,1,0,0,1,0,0,1,0,0,0,0,0,1,2,0,0,0,1,0,0,0,1";
durow[23] = "1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1";
durow[24] = "1,0,1,0,1,6,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1";
durow[25] = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
	for(var M = 0; M <= 25; M++)
	{
		ducolumn = durow[M].split(',');
		duarray[M] = ducolumn;
	}
	return duarray;
}

function dddungeondata4()
{
	var duarray = Array();
	var durow = Array();
	var ducol = Array();
durow[0]  = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
durow[1]  = "1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,7,1,0,0,0,1";
durow[2]  = "1,0,0,0,0,0,3,0,0,0,0,0,3,0,0,0,0,0,0,1,1,1,0,0,0,1";
durow[3]  = "1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,6,0,0,0,0,1";
durow[4]  = "1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,4,1,3,1,1,1,1,0,0,0,1";
durow[5]  = "1,0,0,0,0,0,1,0,1,0,0,0,0,0,4,0,4,0,0,0,0,1,0,0,0,1";
durow[6]  = "1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,4,1,0,0,0,0,1,2,0,0,1";
durow[7]  = "1,1,1,3,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,1";
durow[8]  = "1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,1,3,1,0,0,0,1";
durow[9]  = "1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,1,4,1,3,1";
durow[10] = "1,0,0,1,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1";
durow[11] = "1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1";
durow[12] = "1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,0,1,0,1";
durow[13] = "1,0,0,7,1,6,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1";
durow[14] = "1,1,1,1,1,1,3,1,1,0,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1";
durow[15] = "1,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1";
durow[16] = "1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,2,1,0,1,0,1";
durow[17] = "1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,3,1,0,0,1,0,1,0,1,0,1";
durow[18] = "1,2,0,0,3,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1";
durow[19] = "1,3,1,1,1,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,0,1,0,1";
durow[20] = "1,0,0,0,4,6,4,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1";
durow[21] = "1,0,0,0,1,3,1,4,1,1,1,0,0,0,1,1,1,1,4,1,1,1,4,1,3,1";
durow[22] = "1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,2,0,0,0,0,0,0,0,1";
durow[23] = "1,0,0,0,1,0,0,0,0,0,1,1,1,1,1,3,1,0,0,0,0,0,0,0,0,1";
durow[24] = "1,0,0,0,3,6,0,0,0,0,1,0,0,4,0,0,4,0,0,0,0,0,0,0,0,1";
durow[25] = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
	for(var M = 0; M <= 25; M++)
	{
		ducolumn = durow[M].split(',');
		duarray[M] = ducolumn;
	}
	return duarray;
}

function dddungeondata5()
{
	var duarray = Array();
	var durow = Array();
	var ducol = Array();
durow[0]  = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
durow[1]  = "1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,7,1,0,0,0,1";
durow[2]  = "1,0,0,0,0,0,3,0,0,0,0,0,3,0,0,0,0,0,0,1,1,1,0,0,0,1";
durow[3]  = "1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,6,0,0,0,0,1";
durow[4]  = "1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,0,0,0,1";
durow[5]  = "1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,1";
durow[6]  = "1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,0,1,2,0,0,1";
durow[7]  = "1,1,1,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,4,0,0,0,1";
durow[8]  = "1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,1,3,1,0,0,0,1";
durow[9]  = "1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1";
durow[10] = "1,0,0,1,1,0,0,0,1,0,0,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1";
durow[11] = "1,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1";
durow[12] = "1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,0,1,0,1";
durow[13] = "1,0,0,7,1,6,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1";
durow[14] = "1,1,1,1,1,4,1,1,1,0,0,1,0,0,1,0,1,0,0,1,0,1,1,1,0,1";
durow[15] = "1,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,1,1,0,1";
durow[16] = "1,0,0,0,4,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,2,1,1,1,0,1";
durow[17] = "1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,3,1,0,0,1,0,1,1,1,0,1";
durow[18] = "1,2,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,1";
durow[19] = "1,3,1,1,1,4,1,4,1,0,0,0,0,0,1,1,1,1,1,1,0,1,0,1,0,1";
durow[20] = "1,0,0,0,1,6,4,6,4,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1";
durow[21] = "1,0,0,0,1,4,1,4,1,1,1,0,0,0,1,1,1,1,4,1,1,1,4,1,3,1";
durow[22] = "1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,2,0,0,0,0,0,0,0,1";
durow[23] = "1,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1";
durow[24] = "1,0,0,0,3,6,0,0,0,0,1,0,0,1,1,0,1,0,0,0,0,0,0,0,0,1";
durow[25] = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
	for(var M = 0; M <= 25; M++)
	{
		ducolumn = durow[M].split(',');
		duarray[M] = ducolumn;
	}
	return duarray;
}

function dddungeondata6()
{
	var duarray = Array();
	var durow = Array();
	var ducol = Array();
durow[0]  = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
durow[1]  = "1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,7,1,0,0,0,1";
durow[2]  = "1,0,0,0,0,0,4,0,0,0,0,0,4,0,0,0,0,0,0,1,1,1,0,0,0,1";
durow[3]  = "1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,6,0,0,0,0,1";
durow[4]  = "1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,0,0,0,1";
durow[5]  = "1,0,0,0,0,0,1,0,1,0,0,0,2,0,1,0,1,0,0,0,0,1,0,0,0,1";
durow[6]  = "1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,0,1,2,0,0,1";
durow[7]  = "1,1,1,3,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,1";
durow[8]  = "1,0,0,0,1,0,0,0,3,0,0,0,1,1,1,0,1,1,1,1,3,1,0,0,0,1";
durow[9]  = "1,0,0,0,1,0,0,0,3,0,0,0,0,0,3,0,1,0,0,1,0,1,1,1,1,1";
durow[10] = "1,0,0,1,1,0,0,0,3,0,0,0,0,0,3,0,1,0,0,1,0,1,0,1,0,1";
durow[11] = "1,0,0,0,1,0,0,0,1,3,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1";
durow[12] = "1,0,0,0,1,0,0,0,1,3,3,3,3,3,3,0,1,1,1,1,0,1,0,1,0,1";
durow[13] = "1,0,0,7,1,6,0,0,1,3,6,6,6,3,1,0,0,0,0,1,0,1,0,1,0,1";
durow[14] = "1,1,1,1,1,1,3,1,1,3,6,6,6,3,1,0,1,0,0,1,0,1,1,1,0,1";
durow[15] = "1,0,0,0,1,0,0,0,1,3,6,6,6,3,1,0,1,0,0,1,0,1,1,1,0,1";
durow[16] = "1,0,0,0,1,0,0,0,3,3,3,3,3,3,3,0,1,0,0,1,2,1,1,1,0,1";
durow[17] = "1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,3,1,0,0,1,0,1,1,1,0,1";
durow[18] = "1,2,0,0,3,0,0,0,1,1,4,1,4,1,1,0,1,0,0,1,0,1,1,1,0,1";
durow[19] = "1,3,1,1,1,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,0,1,0,1";
durow[20] = "1,0,0,0,1,6,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1";
durow[21] = "1,0,0,0,1,3,1,3,1,1,1,0,0,0,1,1,1,1,4,1,1,1,4,1,3,1";
durow[22] = "1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,2,0,0,0,0,0,0,0,1";
durow[23] = "1,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1";
durow[24] = "1,0,0,0,3,6,0,0,0,0,1,0,0,1,1,0,1,0,0,0,0,0,0,0,0,1";
durow[25] = "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
	for(var M = 0; M <= 25; M++)
	{
		ducolumn = durow[M].split(',');
		duarray[M] = ducolumn;
	}
	return duarray;
}

function dddisplaydungeon(dungeonmaparray)
{
	for(var M = 0; M <= 25; M++)
	{
		var linestring = '';
		for(var N = 0; N <= 25; N++)
		{
			linestring = linestring+''+dungeonmaparray[M][N];
		}
		ddwr(linestring);
	}
}
</script>
</head>
<body>
<script>

ddinit();
</script>

</body>
